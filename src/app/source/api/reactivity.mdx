> 为了保持 API 文档实时更新，文档由`index.d.ts`文件自动生成。

## useEffect

The function will be called again when the data in the function body has changed,
so you can use this method to listen for a data change.

**示例**

```ts
import { useValue, useComputed } from 'gyron'

const original = useValue(0)
let dummy: number
const s = useEffect(() => {
  dummy = original.value
})
original.value = 10
dummy === original.value // true
s.useEffect.stop()
original.value = 20
dummy === original.value // false
```

**参数说明**

- fn - Callback function after data change.
- dependency - Dependent array functions, where the return value of each function is the object to be dependent on.

**返回值**

Returns a function that can be called directly. The function will have an `effect` object attached to it and the `stop` method on the `effect` object can be accessed to stop listening to the data.

**类型声明**

```ts d
declare function useEffect<T = any>(
  fn: EffectFunction<T>,
  dependency?: Dependency[]
): EffectRunner<T>
```

## useComputed

Similar to the accessor property in javascript,
but changes to the data it depends on will automatically trigger changes to the data that depends on useComputed.

**示例**

```js
import { useValue, useComputed } from 'gyron'

const original = useValue(0)
const observed = useComputed(() => {
  return original.value + 1
})
original.value = 10
observed.value === 11 // true
```

**参数说明**

- getter - Functions for reading data
- setter - Functions for setting data
- dependency - Dependent array functions, where the return value of each function is the object to be dependent on.

**类型声明**

```ts d
declare function useComputed<T>(getter: () => T): Computed<T>
```

## useMemo

If the dependent data is not updated, the value will not be updated.
To avoid this, the data needs to be processed using `useComputed`.

**示例**

```js
import { useValue, useMemo } from 'gyron'

const original = useValue(0)
const memo = useMemo(() => {
  return Date.now() + original.value
})
memo.value === memo.value // true
```

**参数说明**

- getter - Functions for reading data.
- setter - Functions for setting data.
- dependency - Dependent array functions, where the return value of each function is the object to be dependent on.

**类型声明**

```ts d
declare function useMemo<T>(getter: () => T): Computed<T>
```

## useValue

Using the `value` attribute to make basic type data responsive is done
internally using the `useReactive` method and then using `value` as a proxy for the attribute name.

**示例**

```js
import { useValue } from 'gyron'

const original = useValue(0)
original.value === 0 // true
```

**参数说明**

- value - The data that you want to be proxied can be a basic type, such as a number or a boolean.

**返回值**

An object that has been proxied and is accessed using `.value`.

**类型声明**

```ts d
declare function useValue<T = any>(value: T): Primitive<T>
```

## isResponsive

Determines whether an object has responsive characteristics.

**示例**

```js
import { isResponsive } from 'gyron'

isResponsive({}) // false
isResponsive(useReactive({})) // true
```

**类型声明**

```ts d
declare function isResponsive(n: any): n is {
  value: any
}
```

## toRaw

Access to the original data of the object being proxied is very useful in complex objects.
In `useValue` the value object is deconstructed and its original value returned.

**示例**

```javascript
import { useValue } from 'gyron'

const original = useValue(0)
let dummy: number
useEffect(() => {
  dummy = toRaw(original)
})
dummy === 0 // true
original.count = 1
dummy === 0 // true
```

**参数说明**

- observed - Responsive data.

**返回值**

Raw data.

**类型声明**

```ts d
declare function toRaw<T>(observed: T): RawValue<T>
```

## useReactive

Proxy incoming objects, a second parameter can be passed to control whether the object is read-only or not.

**示例**

```js
import { useReactive } from 'gyron'

const original = {
  x: 0,
  y: 0,
}
const observed = useReactive(original)
original !== observed // true
```

**参数说明**

- target - The data that needs to be responded to.
- readonly - Whether the data is read-only.

**返回值**

A proxied object, internally proxied using a `Proxy`.

**类型声明**

```ts d
declare function useReactive<T extends object>(target: T, readonly?: boolean): T
```
