{
  "version": 3,
  "sources": ["../../../runtime/src/index.ts", "../../../shared/src/index.ts", "../../../reactivity/src/effect.ts", "../../../reactivity/src/collection.ts", "../../../reactivity/src/reactive.ts", "../../../reactivity/src/computed.ts", "../../../reactivity/src/primitive.ts", "../../../dom-client/src/opt.ts", "../../../dom-client/src/controlled.ts", "../../../dom-client/src/props.ts", "../../../runtime/src/shared.ts", "../../../runtime/src/vnode.ts", "../../../runtime/src/lifecycle.ts", "../../../runtime/src/boundaries.ts", "../../../runtime/src/assert.ts", "../../../runtime/src/component.ts", "../../../runtime/src/h.ts", "../../../runtime/src/context.ts", "../../../runtime/src/ErrorBoundary.ts", "../../../runtime/src/Transition.ts", "../../../runtime/src/hmr.ts", "../../../runtime/src/ref.ts", "../../../runtime/src/hydrate.ts", "../../../runtime/src/scheduler.ts", "../../../runtime/src/render.ts", "../../../runtime/src/instance.ts", "../../../runtime/src/plugin.ts", "../../../runtime/src/ssr.ts", "../../src/helper.ts", "../../src/index.ts"],
  "sourcesContent": ["export {\n  useReactive,\n  useComputed,\n  useMemo,\n  useValue,\n  useEffect,\n  pauseTrack,\n  enableTrack,\n  cleanupTrackEffect,\n  asyncTrackEffect,\n  clearTrackEffect,\n  isResponsive,\n  toRaw,\n} from '@gyron/reactivity'\nexport { ErrorBoundary } from './ErrorBoundary'\nexport { Transition } from './Transition'\nexport {\n  useWatch,\n  createComponentInstance,\n  renderComponent,\n  getCurrentComponent,\n  defineProps,\n  exposeComponent,\n  forceUpdate,\n  clearCacheComponent,\n  keepComponent,\n  removeBuiltInProps,\n  FCA,\n  FC,\n} from './component'\nexport { createInstance, render, createContext } from './instance'\nexport {\n  createVNode,\n  createVNodeComment,\n  cloneVNode,\n  mergeVNode,\n  normalizeChildrenVNode,\n  normalizeVNode,\n  normalizeVNodeWithLink,\n  Text,\n  Element,\n  Comment,\n  Fragment,\n} from './vnode'\nexport { h } from './h'\nexport { nextRender, useAccrued, useDeferred } from './scheduler'\nexport {\n  onBeforeMount,\n  onAfterMount,\n  onDestroyed,\n  onBeforeUpdate,\n  onAfterUpdate,\n} from './lifecycle'\nexport {\n  isVNode,\n  isVNodeText,\n  isVNodeComment,\n  isVNodeElement,\n  isVNodeFragment,\n  isVNodeComponent,\n} from './shared'\nexport { warn, error } from './assert'\nexport { getPlugins } from './plugin'\nexport { rerender } from './hmr'\nexport {\n  useComponentContext,\n  useProvide,\n  useInject,\n  inject,\n  provide,\n} from './context'\nexport { createSSRInstance, createSSRContext } from './ssr'\nexport {\n  registerErrorHandler,\n  registerWarnHandler,\n  manualErrorHandler,\n  manualWarnHandler,\n} from './boundaries'\nexport { createRef } from './ref'\nexport { hydrate } from './hydrate'\n\nexport type { Primitive, Computed, Effect } from '@gyron/reactivity'\nexport type {\n  Component,\n  ComponentFunction,\n  ComponentSetupFunction,\n  AsyncComponentFunction,\n  ComponentDefaultProps,\n  UtilComponentProps,\n  WrapperFunction,\n} from './component'\nexport type {\n  VNode,\n  VNodeChildren,\n  RenderElement,\n  VNodeProps,\n  Children,\n  VNodeType,\n  VNodeDefaultProps,\n} from './vnode'\nexport type { Plugin } from './plugin'\nexport type { BoundariesHandlerParams } from './boundaries'\nexport type { Instance } from './instance'\nexport type { UserRef } from './ref'\n", "import type { Component } from 'packages/runtime/src/component'\nimport type { Lifecycle } from 'packages/runtime/src/lifecycle'\n\nexport type Noop = () => void\n\nexport function keys(o: any) {\n  return isObject(o) ? Object.keys(o) : []\n}\n\nexport function isUndefined(o: any): o is undefined {\n  return typeof o === 'undefined'\n}\n\nexport function isNull(o: any): o is null {\n  return typeof o === 'object' && !o\n}\n\nexport function isArray(o: any): o is any[] {\n  return Array.isArray(o)\n}\n\nexport function isSet(val: unknown): val is Set<any> {\n  return Object.prototype.toString.call(val) === '[object Set]'\n}\n\nexport function isMap(val: unknown): val is Map<any, any> {\n  return Object.prototype.toString.call(val) === '[object Map]'\n}\n\nexport function isCollection(val: unknown) {\n  const type = Object.prototype.toString.call(val).slice(8, -1)\n  return ['Map', 'Set', 'WeakMap', 'WeakSet'].includes(type)\n}\n\nexport function isBoolean(o: any): o is boolean {\n  return Object.prototype.toString.call(o) === '[object Boolean]'\n}\n\nexport function isObjectPrototype(obj: any): obj is object {\n  return Object.prototype.toString.call(obj) === '[object Object]'\n}\n\nexport function isIntegerKey(key: unknown) {\n  return (\n    isString(key) &&\n    key !== 'NaN' &&\n    key[0] !== '-' &&\n    '' + parseInt(key, 10) === key\n  )\n}\n\nexport function shouldValue(o: any) {\n  if (isArray(o)) {\n    return o.length > 0\n  }\n  return typeof o !== 'undefined' && o !== null\n}\n\nexport function extend<\n  T extends Record<string | symbol, any>,\n  P extends (T | any)[] = (T | any)[]\n>(...args: P): T {\n  return Object.assign(args[0], ...args.slice(1))\n}\n\nexport function isEmpty(o: object) {\n  return isObject(o) && keys(o).length === 0\n}\n\nexport function isObject(o: any): o is Record<any, any> {\n  return o && typeof o === 'object'\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function noop() {}\n\nexport function isElement(o: any) {\n  return o instanceof Node\n}\n\nexport function isComment(node: Node): node is Comment {\n  return node.nodeType === 8\n}\n\nexport function isPromise<T = any>(f: any): f is Promise<T> {\n  return isObject(f) && isFunction(f.then) && isFunction(f.catch)\n}\n\nexport function isString(o: any): o is string {\n  return typeof o === 'string'\n}\n\nexport function isNumber(o: any): o is number {\n  return typeof o === 'number'\n}\n\nexport function isPlanObject(obj: any): obj is { [k: string]: any } {\n  if (!isObjectPrototype(obj)) return false\n\n  const ctor = obj.constructor\n  if (!isFunction(ctor)) return false\n\n  const prot = ctor.prototype\n  if (!isObjectPrototype(prot)) return false\n\n  if (hasOwn(prot, 'isPrototypeOf') === false) {\n    return false\n  }\n\n  return true\n}\n\nexport function isFunction(o: any): o is (...args: any) => any {\n  return o && typeof o === 'function'\n}\n\nexport function hasOwn(\n  val: object,\n  key: string | number | symbol\n): key is keyof typeof val {\n  return Object.prototype.hasOwnProperty.call(val, key)\n}\n\nexport function hasChanged(value: any, oldValue: any): boolean {\n  return !Object.is(value, oldValue)\n}\n\nexport function defineWritable(obj: object, k: any, readonly?: boolean) {\n  Object.defineProperty(obj, k, {\n    configurable: true,\n    writable: !readonly,\n  })\n}\n\nexport function objectReadonlyReducer(obj: any, readonly?: boolean) {\n  for (const k in obj) {\n    if (hasOwn(obj, k)) {\n      const { configurable } = Object.getOwnPropertyDescriptor(obj, k)\n      if (configurable) {\n        const value = obj[k]\n        defineWritable(obj, k, readonly)\n        if (isPlanObject(value)) {\n          objectReadonlyReducer(value, readonly)\n        }\n      }\n    }\n  }\n}\n\nexport function readonly(obj: object) {\n  objectReadonlyReducer(obj, true)\n}\n\nexport function readwrite(obj: object) {\n  objectReadonlyReducer(obj, false)\n}\n\nexport function isReadonly(obj: object, k: any) {\n  const descriptor = Object.getOwnPropertyDescriptor(obj, k)\n  if (descriptor) {\n    return !descriptor.writable\n  }\n  return false\n}\n\nexport function deepObjectMap<T extends object, K extends keyof T>(\n  targets: T,\n  callback: (target: T) => void | boolean,\n  key?: K\n) {\n  if (isObject(targets)) {\n    if (isObjectPrototype(targets)) {\n      const result = callback(targets)\n      if (isBoolean(result) && result) {\n        return targets\n      }\n    }\n    if (hasOwn(targets, key)) {\n      targets = targets[key]\n    }\n    for (const k in targets) {\n      if (hasOwn(targets, k)) {\n        const target = targets[k]\n        if (isObject(target)) {\n          deepObjectMap(target, callback, key)\n        }\n      }\n    }\n  }\n}\n\nexport type ArrayItem<T extends readonly unknown[]> =\n  T extends readonly (infer I)[] ? I : never\n\nexport function deepArrayFind<\n  T extends { [k in S]: any }[],\n  K extends ArrayItem<T>,\n  S extends string\n>(targets: T, key: S, callback: (target: K) => void | boolean): K | void {\n  if (isArray(targets)) {\n    for (const value of targets) {\n      const result = callback(value as K)\n      if (isBoolean(result) && result) {\n        return value as K\n      }\n      if (value[key]) {\n        deepArrayFind(value[key], key, callback)\n      }\n    }\n  }\n}\n\nexport function isEqual<T = any>(target: T, source: T, k?: string) {\n  if (keys(target).length !== keys(source).length) {\n    return false\n  }\n  for (const key in target) {\n    if (key !== k) {\n      const p1 = target[key]\n      const p2 = source[key]\n      if (isArray(p1) && isArray(p2)) {\n        if (p1.length !== p2.length) {\n          return false\n        }\n        for (let i = 0, len = p1.length; i < len; i++) {\n          if (isObject(p1[i]) && isObject(p2[i])) {\n            if (isEqual(p1[i], p2[i], k)) {\n              return false\n            }\n          } else if (p1[i] !== p2[i]) {\n            return false\n          }\n        }\n        return true\n      } else if (target[key] !== source[key]) {\n        return false\n      }\n    }\n  }\n  return true\n}\n\nexport function join(...urls: string[]) {\n  let baseUrl = urls[0]\n  if (!isString(baseUrl)) {\n    return ''\n  }\n  if (baseUrl[0] === '.') {\n    baseUrl = baseUrl.slice(2)\n  }\n  return urls\n    .slice(1)\n    .filter(isString)\n    .reduce((prev, cur) => {\n      while (cur[0] === '.' || cur[0] === '/') {\n        if (cur.slice(0, 2) === '..') {\n          prev = prev.split('/').slice(0, -1).join()\n          // ../\n          cur = cur.slice(3)\n          if (prev === '') {\n            return cur\n          }\n        } else if (cur[0] === '/') {\n          // /\n          cur = cur.slice(1)\n        } else {\n          // ./\n          cur = cur.slice(2)\n        }\n      }\n      if (cur.length) {\n        prev = prev + '/' + cur\n      }\n      return prev\n    }, baseUrl)\n    .replace('//', '/')\n}\n\nexport function resolve(...urls: string[]) {\n  let result = []\n  urls.filter(isString).forEach((url) => {\n    if (url[0] === '/') {\n      result = [url.slice(1)]\n    } else {\n      result.push(url)\n    }\n  })\n  return ('/' + join(...result)).replace('//', '/')\n}\n\nexport function omit<T extends object, K extends keyof T | (keyof T)[]>(\n  o: T,\n  k: K\n): Omit<T, K extends Array<any> ? K[number] : K> {\n  const target: any = {}\n  for (const key in o) {\n    if (isArray(k)) {\n      if (!k.includes(key)) {\n        target[key] = o[key]\n      }\n    } else {\n      if ((k as keyof T) !== key) {\n        target[key] = o[key]\n      }\n    }\n  }\n  return target\n}\n\nexport function merge<T = any>(target: any, source?: any): T {\n  if (shouldValue(source)) {\n    if (isArray(target)) {\n      if (isArray(source)) {\n        target.push(...source)\n      } else {\n        target.push(source)\n      }\n    } else if (isPlanObject(target)) {\n      extend(target, source || {})\n    } else if (isUndefined(target) || isNull(target)) {\n      target = source\n    }\n  }\n  return target\n}\n\nexport function sleep<T = any>(ms: number, value?: T): Promise<T> {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(value)\n    }, ms)\n  })\n}\n\nexport function sleepWithRequestFrame() {\n  return new Promise((resolve) => {\n    requestAnimationFrame(resolve)\n  })\n}\n\nexport function removeWithString(target: string, values: string[]) {\n  return target\n    .split(' ')\n    .filter((item) => !values.includes(item))\n    .join(' ')\n}\n\nexport function escape(string: unknown) {\n  const escapeRE = /[\"'&<>]/\n  const str = String(string)\n  const match = escapeRE.exec(str)\n\n  if (!match) {\n    return str\n  }\n\n  let html = ''\n  let escaped: string\n  let index: number\n  let lastIndex = 0\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escaped = '&quot;'\n        break\n      case 38: // &\n        escaped = '&amp;'\n        break\n      case 39: // '\n        escaped = '&#39;'\n        break\n      case 60: // <\n        escaped = '&lt;'\n        break\n      case 62: // >\n        escaped = '&gt;'\n        break\n      default:\n        continue\n    }\n\n    if (lastIndex !== index) {\n      html += str.slice(lastIndex, index)\n    }\n\n    lastIndex = index + 1\n    html += escaped\n  }\n\n  return lastIndex !== index ? html + str.slice(lastIndex, index) : html\n}\n\nexport function diffWord(words: string[], newWords: string[]) {\n  const kindDeleteWords: string[] = []\n  const kindAddWords: string[] = []\n  words.filter(Boolean).forEach((word) => {\n    if (!newWords.includes(word)) {\n      kindDeleteWords.push(word)\n    }\n  })\n  newWords.filter(Boolean).forEach((word) => {\n    if (!words.includes(word)) {\n      kindAddWords.push(word)\n    }\n  })\n  return {\n    D: kindDeleteWords,\n    A: kindAddWords,\n  }\n}\n\nexport function isEventProps(name: string) {\n  return /^on[A-Z]/.test(name)\n}\n\nexport function normalizeEventName(name: string) {\n  return name.slice(2).toLocaleLowerCase()\n}\n\nexport function initialLifecycle(component: Component, key: keyof Lifecycle) {\n  if (!component.lifecycle) {\n    component.lifecycle = {\n      [key]: new Set(),\n    }\n  }\n  if (!component.lifecycle[key]) {\n    component.lifecycle[key] = new Set()\n  }\n}\n", "import { isArray, isIntegerKey, isMap, Noop } from '@gyron/shared'\nimport { ReactiveFlags } from './reactive'\n\nlet activeEffect: Effect | undefined\n\nexport const effectTracks = new WeakMap<any, Map<any, Dep>>()\n\nexport type Dep = Set<Effect>\nexport type EffectScheduler = (...args: any[]) => any\n\nexport interface EffectRunner<T = any> {\n  (): T\n  effect: Effect\n}\n\nexport type Dependency = () => any\n\nexport type EffectFunction<T> = (...args: any) => T\n\nexport const enum TrackTypes {\n  GET = 'get',\n  HAS = 'has',\n  ITERATE = 'iterate',\n}\n\nexport const enum TriggerTypes {\n  SET = 'set',\n  ADD = 'add',\n  DELETE = 'delete',\n  CLEAR = 'clear',\n}\n\nexport const ITERATE_KEY = Symbol.for('gyron.iterate')\nexport const MAP_KEY_ITERATE_KEY = Symbol.for('gyron.map-iterate')\n\nlet shouldTrack = true\n\nexport function pauseTrack() {\n  shouldTrack = false\n}\n\nexport function enableTrack() {\n  shouldTrack = true\n}\n\nexport function asyncTrackEffect(effect: Effect) {\n  activeEffect = effect\n}\n\nexport function clearTrackEffect() {\n  activeEffect = undefined\n}\n\nexport interface Effect {\n  deps: Dep[]\n  allowEffect: boolean\n  scheduler: EffectScheduler | null\n  wrapper: Noop\n  run: () => any\n  stop: Noop\n}\n\nexport function createEffect(\n  fn: Noop,\n  scheduler: EffectScheduler | null = null,\n  dependency: Dependency[] = []\n) {\n  let prevActiveEffect: Effect = null\n\n  const effect: Effect = {\n    deps: [],\n    allowEffect: null,\n    scheduler,\n    run: () => {\n      try {\n        prevActiveEffect = activeEffect\n        activeEffect = effect\n\n        effect.wrapper()\n\n        return fn()\n      } finally {\n        activeEffect = prevActiveEffect\n        prevActiveEffect = null\n      }\n    },\n    stop: () => {\n      const { deps } = effect\n      if (deps.length) {\n        for (let i = 0; i < deps.length; i++) {\n          deps[i].delete(effect)\n        }\n        deps.length = 0\n      }\n    },\n    wrapper: () => {\n      for (let i = 0; i < dependency.length; i++) {\n        const fn = dependency[i]\n        fn()\n      }\n    },\n  }\n\n  return effect\n}\n\n/**\n * The function will be called again when the data in the function body has changed,\n * so you can use this method to listen for a data change.\n * ```ts\n * import { useValue, useComputed } from 'gyron'\n *\n * const original = useValue(0)\n * let dummy: number\n * const s = useEffect(() => {\n *   dummy = original.value\n * })\n * original.value = 10\n * dummy === original.value // true\n * s.useEffect.stop()\n * original.value = 20\n * dummy === original.value // false\n * ```\n * @api reactivity\n * @param fn Callback function after data change.\n * @param dependency Dependent array functions, where the return value of each function is the object to be dependent on.\n * @returns Returns a function that can be called directly. The function will have an `effect` object attached to it and the `stop` method on the `effect` object can be accessed to stop listening to the data.\n */\nexport function useEffect<T = any>(\n  fn: EffectFunction<T>,\n  dependency?: Dependency[]\n) {\n  const effect = createEffect(fn, null, dependency)\n  effect.run()\n  const runner = effect.run.bind(effect) as EffectRunner<T>\n  runner.effect = effect\n  return runner\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function track(target: object, key: unknown, type: TrackTypes) {\n  if (shouldTrack && activeEffect) {\n    let targetTracks = effectTracks.get(target)\n    if (!targetTracks) {\n      effectTracks.set(target, (targetTracks = new Map()))\n    }\n    let targetDep = targetTracks.get(key)\n    if (!targetDep) {\n      targetTracks.set(key, (targetDep = new Set()))\n    }\n\n    trackEffect(targetDep)\n  }\n}\n\nexport function trackEffect(dep: Dep) {\n  if (activeEffect && !dep.has(activeEffect)) {\n    dep.add(activeEffect)\n    activeEffect.deps.push(dep)\n  }\n}\n\nexport function cleanupTrackEffect(target: object, key: string | symbol) {\n  const depsMap = effectTracks.get(\n    target[ReactiveFlags.IS_PRIMITIVE]\n      ? target[ReactiveFlags.RAW_VALUE]\n      : target[ReactiveFlags.RAW]\n  )\n  if (depsMap) {\n    const deps = depsMap.get(key)\n    if (deps) {\n      deps.clear()\n    }\n  }\n}\n\nexport function trigger(\n  target: object,\n  key: unknown,\n  type: TriggerTypes,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  value?: unknown\n) {\n  const targetTracks = effectTracks.get(target)\n  if (targetTracks) {\n    const deps: Dep[] = []\n    if (key === 'length' && isArray(target)) {\n      targetTracks.forEach((dep, key) => {\n        if (key === 'length') {\n          deps.push(dep)\n        }\n      })\n    } else {\n      deps.push(targetTracks.get(key))\n\n      switch (type) {\n        case TriggerTypes.ADD:\n          if (!isArray(target)) {\n            deps.push(targetTracks.get(ITERATE_KEY))\n            if (isMap(target)) {\n              deps.push(targetTracks.get(MAP_KEY_ITERATE_KEY))\n            }\n          } else if (isIntegerKey(key)) {\n            // new index added to array -> length changes\n            deps.push(targetTracks.get('length'))\n          }\n          break\n        case TriggerTypes.DELETE:\n          if (!isArray(target)) {\n            deps.push(targetTracks.get(ITERATE_KEY))\n            if (isMap(target)) {\n              deps.push(targetTracks.get(MAP_KEY_ITERATE_KEY))\n            }\n          }\n          break\n        case TriggerTypes.SET:\n          if (isMap(target)) {\n            deps.push(targetTracks.get(ITERATE_KEY))\n          }\n          break\n      }\n    }\n    if (deps.length === 1) {\n      if (deps[0]) {\n        triggerEffect(deps[0])\n      }\n    } else {\n      const effects: Effect[] = []\n      for (const dep of deps) {\n        if (dep) {\n          effects.push(...dep)\n        }\n      }\n      triggerEffect(new Set(effects))\n    }\n  }\n}\n\nexport function triggerEffect(dep: Dep | Effect[]) {\n  const deps = isArray(dep) ? dep : [...dep]\n  for (const effect of deps) {\n    if (effect !== activeEffect || effect.allowEffect) {\n      if (effect.scheduler) {\n        effect.scheduler()\n      } else {\n        effect.run()\n      }\n    }\n  }\n}\n", "import { hasChanged, hasOwn, isMap, Noop } from '@gyron/shared'\nimport {\n  ITERATE_KEY,\n  MAP_KEY_ITERATE_KEY,\n  track,\n  TrackTypes,\n  trigger,\n  TriggerTypes,\n} from './effect'\nimport { ReactiveFlags, toRaw } from './reactive'\n\nexport type CollectionTypes = IterableCollections | WeakCollections\n\ntype IterableCollections = Map<any, any> | Set<any>\ntype WeakCollections = WeakMap<any, any> | WeakSet<any>\ntype MapTypes = Map<any, any> | WeakMap<any, any>\ntype SetTypes = Set<any> | WeakSet<any>\n\ninterface Iterable {\n  [Symbol.iterator](): Iterator\n}\n\ninterface Iterator {\n  next(value?: any): IterationResult\n}\n\ninterface IterationResult {\n  value: any\n  done: boolean\n}\n\nconst getProto = <T extends CollectionTypes>(v: T): any =>\n  Reflect.getPrototypeOf(v)\n\nfunction get(target: MapTypes, key: unknown) {\n  target = (target as any)[ReactiveFlags.RAW]\n  const rawTarget = toRaw(target)\n  const rawKey = toRaw(key)\n  if (key !== rawKey) {\n    track(rawTarget, key, TrackTypes.GET)\n  }\n  track(rawTarget, rawKey, TrackTypes.GET)\n  const { has } = getProto(rawTarget)\n  if (has.call(rawTarget, key)) {\n    return target.get(key)\n  } else if (has.call(rawTarget, rawKey)) {\n    return target.get(rawKey)\n  } else if (target !== rawTarget) {\n    target.get(key)\n  }\n}\n\nfunction add(this: SetTypes, value: unknown) {\n  value = toRaw(value)\n  const target = toRaw(this)\n  const proto = getProto(target)\n  const hadKey = proto.has.call(target, value)\n  if (!hadKey) {\n    target.add(value)\n    trigger(target, value, TriggerTypes.ADD)\n  }\n  return this\n}\n\nfunction has(this: CollectionTypes, key: unknown): boolean {\n  const target = (this as any)[ReactiveFlags.RAW]\n  const rawTarget = toRaw(target)\n  const rawKey = toRaw(key)\n  if (key !== rawKey) {\n    track(rawTarget, key, TrackTypes.HAS)\n  }\n  track(rawTarget, rawKey, TrackTypes.HAS)\n  return key === rawKey\n    ? target.has(key)\n    : target.has(key) || target.has(rawKey)\n}\n\nfunction size(target: IterableCollections) {\n  target = (target as any)[ReactiveFlags.RAW]\n  track(toRaw(target), ITERATE_KEY, TrackTypes.ITERATE)\n  return Reflect.get(target, 'size', target)\n}\n\nfunction set(this: MapTypes, key: unknown, value: unknown) {\n  value = toRaw(value)\n  const target = toRaw(this)\n  const { has, get } = getProto(target)\n\n  let hadKey = has.call(target, key)\n  if (!hadKey) {\n    key = toRaw(key)\n    hadKey = has.call(target, key)\n  }\n\n  const oldValue = get.call(target, key)\n  target.set(key, value)\n  if (!hadKey) {\n    trigger(target, key, TriggerTypes.ADD, value)\n  } else if (hasChanged(value, oldValue)) {\n    trigger(target, key, TriggerTypes.SET, value)\n  }\n  return this\n}\n\nfunction deleteEntry(this: CollectionTypes, key: unknown) {\n  const target = toRaw(this)\n  const { has } = getProto(target)\n  let hadKey = has.call(target, key)\n  if (!hadKey) {\n    key = toRaw(key)\n    hadKey = has.call(target, key)\n  }\n  const result = target.delete(key)\n  if (hadKey) {\n    trigger(target, key, TriggerTypes.DELETE)\n  }\n  return result\n}\n\nfunction clear(this: IterableCollections) {\n  const target = toRaw(this)\n  const hadItems = target.size !== 0\n  const result = target.clear()\n  if (hadItems) {\n    trigger(target, undefined, TriggerTypes.CLEAR)\n  }\n  return result\n}\n\nfunction createForEach() {\n  return function forEach(\n    this: IterableCollections,\n    callback: Noop,\n    thisArg?: unknown\n  ) {\n    const observed = this as any\n    const target = observed[ReactiveFlags.RAW]\n    const rawTarget = toRaw(target)\n    track(rawTarget, ITERATE_KEY, TrackTypes.ITERATE)\n    return target.forEach((value: unknown, key: unknown) => {\n      return callback.call(thisArg, value, key, observed)\n    })\n  }\n}\n\nfunction createIterableMethod(method: string | symbol) {\n  return function (\n    this: IterableCollections,\n    ...args: unknown[]\n  ): Iterable & Iterator {\n    const target = (this as any)[ReactiveFlags.RAW]\n    const rawTarget = toRaw(target)\n    const targetIsMap = isMap(rawTarget)\n    const isPair =\n      method === 'entries' || (method === Symbol.iterator && targetIsMap)\n    const isKeyOnly = method === 'keys' && targetIsMap\n    const innerIterator = target[method](...args)\n    track(\n      rawTarget,\n      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY,\n      TrackTypes.ITERATE\n    )\n    // return a wrapped iterator which returns observed versions of the\n    // values emitted from the real iterator\n    return {\n      next() {\n        const { value, done } = innerIterator.next()\n        return done\n          ? { value, done }\n          : {\n              value: isPair ? [value[0], value[1]] : value,\n              done,\n            }\n      },\n      [Symbol.iterator]() {\n        return this\n      },\n    }\n  }\n}\n\nexport const collectionHandlers: ProxyHandler<object> = {\n  get: (\n    target: CollectionTypes,\n    key: string | symbol,\n    receiver: CollectionTypes\n  ) => {\n    const collections = {\n      get size() {\n        return size(this as unknown as IterableCollections)\n      },\n      get(this: MapTypes, key: unknown) {\n        return get(this, key)\n      },\n      has,\n      add,\n      set,\n      delete: deleteEntry,\n      clear,\n      forEach: createForEach(),\n      keys: createIterableMethod('keys'),\n      values: createIterableMethod('values'),\n      entries: createIterableMethod('entries'),\n      [Symbol.iterator]: createIterableMethod(Symbol.iterator),\n    }\n    if (key === ReactiveFlags.RAW) {\n      return target\n    }\n    return Reflect.get(\n      hasOwn(collections, key) && key in target ? collections : target,\n      key,\n      receiver\n    )\n  },\n}\n", "import {\n  hasChanged,\n  hasOwn,\n  isArray,\n  isCollection,\n  isObject,\n  isReadonly,\n  isUndefined,\n  objectReadonlyReducer,\n} from '@gyron/shared'\nimport { collectionHandlers, CollectionTypes } from './collection'\nimport { Computed } from './computed'\nimport {\n  pauseTrack,\n  enableTrack,\n  track,\n  TrackTypes,\n  trigger,\n  TriggerTypes,\n  ITERATE_KEY,\n} from './effect'\nimport { Primitive } from './primitive'\n\nexport type ReactValue<T> = Primitive<T> | Computed<T>\n\nexport type RawValue<T> = T extends ReactValue<infer V> ? V : T\n\nexport const reactiveMap = new WeakMap<object | CollectionTypes, any>()\n\nexport const enum ReactiveFlags {\n  IS_REACTIVE = '_reactive_',\n  IS_COMPUTED = '_computed_',\n  IS_PRIMITIVE = '_primitive_',\n  IS_READONLY = '_readonly_',\n  RAW = '_raw_',\n  RAW_VALUE = '_raw_value_',\n}\n\nexport interface Target {\n  [ReactiveFlags.IS_REACTIVE]?: boolean\n  [ReactiveFlags.IS_COMPUTED]?: boolean\n  [ReactiveFlags.IS_PRIMITIVE]?: boolean\n  [ReactiveFlags.IS_READONLY]?: boolean\n  [ReactiveFlags.RAW]?: any\n}\n\n/**\n * Determines whether an object has responsive characteristics.\n * ```js\n * import { isResponsive } from 'gyron'\n *\n * isResponsive({}) // false\n * isResponsive(useReactive({})) // true\n * ```\n * @api reactivity\n */\nexport function isResponsive(n: any): n is { value: any } {\n  // reactivity/src/useReactive ReactiveFlags\n  return (\n    isObject(n) &&\n    Boolean(\n      n[ReactiveFlags.IS_REACTIVE] ||\n        n[ReactiveFlags.IS_COMPUTED] ||\n        n[ReactiveFlags.IS_PRIMITIVE]\n    )\n  )\n}\n\n/**\n * Access to the original data of the object being proxy is very useful in complex objects.\n * In `useValue` the value object is deconstructed and its original value returned.\n * ```javascript\n * import { useValue } from 'gyron'\n *\n * const original = useValue(0)\n * let dummy: number\n * useEffect(() => {\n *   dummy = toRaw(original)\n * })\n * dummy === 0 // true\n * original.count = 1\n * dummy === 0 // true\n * ```\n * @api reactivity\n * @param observed Responsive data.\n * @returns Raw data.\n */\nexport function toRaw<T>(observed: T): RawValue<T> {\n  const raw = !isUndefined(observed) && (observed as Target)[ReactiveFlags.RAW]\n  if (!isUndefined(raw)) {\n    return toRaw(raw)\n  }\n  return observed as RawValue<T>\n}\n\nconst arrayInstrumentations = createArrayInstrumentations()\n\nfunction createArrayInstrumentations() {\n  const instrumentations: Record<string, () => any> = {}\n  ;(['includes', 'indexOf', 'lastIndexOf'] as const).forEach((key) => {\n    instrumentations[key] = function (this: unknown[], ...args: unknown[]) {\n      const arr = toRaw(this) as any\n      for (let i = 0, l = this.length; i < l; i++) {\n        track(arr, i + '', TrackTypes.GET)\n      }\n      // we run the method using the original args first (which may be useReactive)\n      const res = arr[key](...args)\n      if (res === -1 || res === false) {\n        // if that didn't work, run it again using raw values.\n        return arr[key](...args.map(toRaw))\n      } else {\n        return res\n      }\n    }\n  })\n  ;(['push', 'pop', 'shift', 'unshift', 'splice'] as const).forEach((key) => {\n    instrumentations[key] = function (this: any, ...args: unknown[]) {\n      pauseTrack()\n      const res = (this[ReactiveFlags.RAW] as any)[key].apply(this, args)\n      enableTrack()\n      return res\n    }\n  })\n  return instrumentations\n}\n\nfunction get(target: object, key: string | symbol, receiver: object) {\n  if (key === ReactiveFlags.IS_REACTIVE) {\n    return true\n  }\n  if (key === ReactiveFlags.RAW) {\n    return target\n  }\n\n  const targetIsArray = Array.isArray(target)\n\n  if (targetIsArray) {\n    if (hasOwn(arrayInstrumentations, key)) {\n      // skip listening to the array's built-in methods, which access the array's length, and just listen to the length.\n      return Reflect.get(arrayInstrumentations, key, receiver)\n    }\n  }\n\n  const res = Reflect.get(target, key, receiver)\n\n  track(target, key, TrackTypes.GET)\n\n  if (res && typeof res === 'object' && !isResponsive(res)) {\n    // deep useReactive\n    return useReactive(res)\n  }\n\n  return res\n}\n\nfunction set(\n  target: object,\n  key: string | symbol,\n  value: unknown,\n  receiver: object\n) {\n  if (isReadonly(target, key)) {\n    return false\n  }\n\n  const oldValue = (target as any)[key]\n\n  const res = Reflect.set(target, key, value, receiver)\n\n  if (hasChanged(oldValue, value) || isArray(target)) {\n    trigger(target, key, TriggerTypes.ADD)\n  }\n\n  return res\n}\n\nfunction has(target: object, key: string | symbol) {\n  const res = Reflect.has(target, key)\n  track(target, key, TrackTypes.HAS)\n  return res\n}\n\nfunction deleteProperty(target: object, key: string | symbol) {\n  if (isReadonly(target, key)) {\n    return false\n  }\n\n  trigger(target, key, TriggerTypes.DELETE)\n\n  return Reflect.deleteProperty(target, key)\n}\n\nfunction ownKeys(target: object) {\n  const res = Reflect.ownKeys(target)\n  track(target, isArray(target) ? 'length' : ITERATE_KEY, TrackTypes.ITERATE)\n  return res\n}\n\nconst mutableHandlers: ProxyHandler<object> = {\n  get,\n  set,\n  has,\n  deleteProperty,\n  ownKeys,\n}\n\n/**\n * Proxy incoming objects, a second parameter can be passed to control whether the object is read-only or not.\n * ```js\n * import { useReactive } from 'gyron'\n *\n * const original = {\n *   x: 0,\n *   y: 0,\n * }\n * const observed = useReactive(original)\n * original !== observed // true\n * ```\n * @api reactivity\n * @param target The data that needs to be responded to.\n * @param readonly Whether the data is read-only.\n * @returns A proxy object, internally proxy using a `Proxy`.\n */\nexport function useReactive<T extends object>(\n  target: T,\n  readonly?: boolean\n): T {\n  const existingProxy = reactiveMap.get(target)\n  if (existingProxy) {\n    return existingProxy\n  }\n\n  if (readonly) {\n    objectReadonlyReducer(target, readonly)\n  }\n\n  const proxy = new Proxy<T>(\n    target,\n    isCollection(target) ? collectionHandlers : mutableHandlers\n  )\n  reactiveMap.set(target, proxy)\n\n  return proxy\n}\n", "import { isArray, isFunction, isUndefined, noop } from '@gyron/shared'\nimport {\n  Dep,\n  Dependency,\n  Effect,\n  enableTrack,\n  pauseTrack,\n  createEffect,\n  trackEffect,\n  triggerEffect,\n} from './effect'\nimport { ReactiveFlags } from './reactive'\n\nexport class Computed<T = any> {\n  private _effect: Effect\n  private _value!: T\n  private _lazy = true\n  public dep: Dep | undefined\n\n  public [ReactiveFlags.IS_COMPUTED] = true\n\n  constructor(\n    private getter: () => T,\n    private setter: (v: T) => void,\n    private dependency: Dependency[] = [],\n    private memo = false\n  ) {\n    this._effect = createEffect(\n      this.getter,\n      () => {\n        if (this.memo) {\n          if (!this._lazy) {\n            this._lazy = true\n            triggerEffect(this.dep)\n          }\n        } else {\n          triggerEffect(this.dep)\n        }\n      },\n      this.dependency\n    )\n  }\n\n  get value() {\n    trackEffect(this.dep || (this.dep = new Set()))\n    if (this.memo) {\n      if (this._lazy) {\n        this._lazy = false\n        this._value = this._effect.run()\n      }\n    } else {\n      this._value = this._effect.run()\n    }\n    return this._value\n  }\n\n  set value(v) {\n    this.setter(v)\n  }\n\n  get [ReactiveFlags.RAW]() {\n    try {\n      pauseTrack()\n      return this._effect.run()\n    } finally {\n      enableTrack()\n    }\n  }\n}\n\nfunction wrapperComputed<T>(\n  getter: () => T,\n  unstable: ((value: T) => void) | Dependency[],\n  dependency: Dependency[],\n  memo: boolean\n) {\n  let setter: (value: T) => void\n  if (isFunction(unstable)) {\n    setter = unstable\n  } else if (isUndefined(unstable)) {\n    setter = noop\n  } else if (isArray(unstable)) {\n    dependency = unstable\n    setter = noop\n  }\n  return new Computed<T>(getter, setter, dependency, memo)\n}\n\n/**\n * Similar to the accessor property in javascript,\n * but changes to the data it depends on will automatically trigger changes to the data that depends on useComputed.\n * ```js\n * import { useValue, useComputed } from 'gyron'\n *\n * const original = useValue(0)\n * const observed = useComputed(() => {\n *   return original.value + 1\n * })\n * original.value = 10\n * observed.value === 11 // true\n * ```\n * @api reactivity\n * @param getter Functions for reading data\n * @param setter Functions for setting data\n * @param dependency Dependent array functions, where the return value of each function is the object to be dependent on.\n */\nexport function useComputed<T>(getter: () => T): Computed<T>\nexport function useComputed<T>(\n  getter: () => T,\n  dependency: Dependency[]\n): Computed<T>\nexport function useComputed<T>(\n  getter: () => T,\n  setter: (value: T) => void,\n  dependency: Dependency[]\n): Computed<T>\nexport function useComputed(getter: any, unstable?: any, dependency?: any) {\n  return wrapperComputed(getter, unstable, dependency, false)\n}\n\n/**\n * If the dependent data is not updated, the value will not be updated.\n * To avoid this, the data needs to be processed using `useComputed`.\n * ```js\n * import { useValue, useMemo } from 'gyron'\n *\n * const original = useValue(0)\n * const memo = useMemo(() => {\n *   return Date.now() + original.value\n * })\n * memo.value === memo.value // true\n * ```\n * @api reactivity\n * @param getter Functions for reading data.\n * @param setter Functions for setting data.\n * @param dependency Dependent array functions, where the return value of each function is the object to be dependent on.\n */\nexport function useMemo<T>(getter: () => T): Computed<T>\nexport function useMemo<T>(\n  getter: () => T,\n  dependency: Dependency[]\n): Computed<T>\nexport function useMemo<T>(\n  getter: () => T,\n  setter: (value: T) => void,\n  dependency: Dependency[]\n): Computed<T>\nexport function useMemo(getter: any, unstable?: any, dependency?: any) {\n  return wrapperComputed(getter, unstable, dependency, true)\n}\n", "import { useReactive, ReactiveFlags, toRaw } from './reactive'\n\nexport class Primitive<T = any> {\n  private _value: { value: T }\n\n  public [ReactiveFlags.IS_PRIMITIVE] = true\n\n  constructor(value: T) {\n    this._value = useReactive<{ value: T }>({\n      value,\n    })\n  }\n\n  get value() {\n    return this._value.value\n  }\n\n  set value(v) {\n    this._value.value = v\n  }\n\n  get [ReactiveFlags.RAW]() {\n    return toRaw(this._value.value)\n  }\n\n  get [ReactiveFlags.RAW_VALUE]() {\n    return toRaw(this._value)\n  }\n}\n\n/**\n * Using the `value` attribute to make basic type data responsive is done\n * internally using the `useReactive` method and then using `value` as a proxy for the attribute name.\n * ```js\n * import { useValue } from 'gyron'\n *\n * const original = useValue(0)\n * original.value === 0 // true\n * ```\n * @api reactivity\n * @param value The data that you want to be proxied can be a basic type, such as a number or a boolean.\n * @returns An object that has been proxied and is accessed using `.value`.\n */\nexport function useValue<T = any>(value: T) {\n  return new Primitive(value)\n}\n", "import { isComment } from '@gyron/shared'\n\nexport const NS = 'http://www.w3.org/2000/svg'\n\nexport function insert(child: Node, parent: Node, anchor?: Node) {\n  if (anchor && parent.contains(anchor)) {\n    parent.insertBefore(child, anchor)\n  } else {\n    append(child, parent)\n  }\n}\n\nexport function append(child: Node, parent: any) {\n  parent.appendChild(child)\n}\n\nexport function remove(child: Element | Comment) {\n  child.remove()\n}\n\nexport function createElement(tag: string, isSvg?: boolean, is?: any) {\n  const el = isSvg\n    ? document.createElementNS(NS, tag)\n    : document.createElement(tag, is ? { is } : undefined)\n\n  return el\n}\n\nexport function createText(text: string) {\n  return document.createTextNode(text)\n}\n\nexport function createComment(data?: string) {\n  return document.createComment(data || '')\n}\n\nexport function nextSibling(node: Node) {\n  let nextNode = node.nextSibling\n  while (nextNode && isComment(nextNode) && nextNode.data === '|') {\n    nextNode = nextNode.nextSibling\n  }\n  return nextNode\n}\n\nexport function querySelector(selector: string, container?: Element) {\n  return (container || document).querySelector(selector)\n}\n", "import type { Component, VNode, RenderElement } from 'packages/gyron/src'\nimport { initialLifecycle, isArray, isSet } from '@gyron/shared'\n\nfunction setSelectValue(el: HTMLSelectElement, value: any) {\n  const isMultiple = el.multiple\n  if (isMultiple && !isArray(value) && !isSet(value)) {\n    console.warn(\n      'There is a multiple attribute in select, so the value of the value attribute must be an array'\n    )\n    return null\n  }\n  for (let i = 0; i < el.options.length; i++) {\n    const option = el.options[i]\n    const optionValue = option.value\n    if (isMultiple) {\n      if (isArray(value)) {\n        option.selected = value.includes(optionValue)\n      } else {\n        option.selected = value.has(optionValue)\n      }\n    } else {\n      if (optionValue === value) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple && el.selectedIndex !== -1) {\n    el.selectedIndex = -1\n  }\n}\n\nfunction getComponentByVNode(vnode: VNode): void | Component {\n  let parent = vnode\n  while (parent && !parent.component) {\n    parent = parent.parent\n  }\n  if (!parent) {\n    console.warn(\n      'No vnode found in the vnode chain containing component attributes',\n      vnode\n    )\n    return null\n  }\n  return parent.component\n}\n\nfunction selectElementControlled(el: RenderElement, value: any, vnode: VNode) {\n  const component = getComponentByVNode(vnode)\n  if (component) {\n    if (component.mounted) {\n      setSelectValue(el as HTMLSelectElement, value)\n    } else {\n      initialLifecycle(component, 'afterMounts')\n      component.lifecycle.afterMounts.add(\n        setSelectValue.bind(null, el as HTMLSelectElement, value)\n      )\n    }\n  }\n}\n\nexport function controlledElementValue(\n  el: RenderElement,\n  key: string,\n  value: any,\n  vnode: VNode\n) {\n  switch (el.nodeName) {\n    case 'SELECT':\n      selectElementControlled(el, value, vnode)\n      break\n    default:\n      el[key] = value\n  }\n}\n\nexport function isControlledElementProp(el: RenderElement, key: string) {\n  switch (el.nodeName) {\n    case 'SELECT':\n    case 'TEXTAREA':\n      return key === 'value'\n    case 'INPUT':\n      switch ((el as HTMLInputElement).type) {\n        case 'radio':\n        case 'checkbox':\n          return key === 'checked'\n        default:\n          return key === 'value'\n      }\n  }\n  return false\n}\n\nexport function isSelectElement(vnode: VNode) {\n  return vnode.el && vnode.el.nodeName === 'SELECT'\n}\n", "import type { VNode, VNodeProps } from 'packages/gyron/src'\nimport {\n  diffWord,\n  isBoolean,\n  isEventProps,\n  isObject,\n  isString,\n  keys,\n  normalizeEventName,\n  shouldValue,\n} from '@gyron/shared'\nimport { isControlledElementProp, controlledElementValue } from './controlled'\nimport { NS } from './opt'\n\nexport type Listener = () => any\nexport type Style = string | Record<string, string>\n\ninterface DebugOption {\n  update: (type: string) => void\n}\n\nfunction setAttribute(el: Element, key: string, value: any, vnode: VNode) {\n  if (el.nodeName === 'SVG') {\n    el.setAttributeNS(NS, key, value)\n  } else {\n    if (isControlledElementProp(el, key)) {\n      // controlled component values require special handling\n      controlledElementValue(el, key, value, vnode)\n    } else {\n      if (isBoolean(value)) {\n        // https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#boolean-attributes\n        if (value) {\n          el.setAttribute(key, '')\n        } else {\n          // attribute falsy should remove\n          el.removeAttribute(key)\n        }\n      } else {\n        el.setAttribute(key, value)\n      }\n    }\n  }\n}\n\nfunction removeAttribute(el: Element, key: string) {\n  if (el.nodeName === 'SVG') {\n    el.removeAttributeNS(NS, key)\n  } else {\n    el.removeAttribute(key)\n  }\n}\n\nfunction unmountProps(\n  el: Element,\n  unmounts: string[],\n  props: Partial<VNodeProps>\n) {\n  for (const key of unmounts) {\n    if (isEventProps(key)) {\n      el.removeEventListener(normalizeEventName(key), props[key])\n    } else {\n      removeAttribute(el, key)\n    }\n  }\n}\n\nfunction patchEvent(\n  el: Element,\n  key: string,\n  oldEvent: Listener,\n  newEvent: Listener,\n  debugOption?: DebugOption\n) {\n  if (newEvent) {\n    if (newEvent !== oldEvent) {\n      el.removeEventListener(key, oldEvent)\n      el.addEventListener(key, newEvent)\n      if (__DEV__ && debugOption) {\n        debugOption.update('event')\n      }\n    }\n  }\n}\n\nfunction patchClass(\n  el: Element,\n  oldValue: string,\n  value: string,\n  debugOption?: DebugOption\n) {\n  if (oldValue === value) {\n    return\n  }\n\n  const { D, A } = diffWord(\n    isString(oldValue) ? oldValue.split(' ') : [],\n    isString(value) ? value.split(' ') : []\n  )\n\n  el.classList.remove(...D)\n\n  if (!value) {\n    removeAttribute(el, 'class')\n  } else {\n    el.classList.add(...A)\n  }\n\n  if (__DEV__ && debugOption && (D.length || A.length)) {\n    debugOption.update('class')\n  }\n}\n\nfunction patchStyle(\n  el: Element,\n  oldValue: Style | null,\n  value: Style | null,\n  vnode: VNode,\n  debugOption?: DebugOption\n) {\n  if (isString(value)) {\n    if (value !== oldValue) {\n      setAttribute(el, 'style', value, vnode)\n    }\n  } else {\n    if (isObject(value)) {\n      for (const [css, cssValue] of Object.entries(value)) {\n        if (!oldValue || oldValue[css] !== cssValue) {\n          ;(el as HTMLElement).style[css] = cssValue\n          if (__DEV__ && debugOption) {\n            debugOption.update('style')\n          }\n        }\n      }\n      if (isObject(oldValue)) {\n        for (const css in oldValue) {\n          if (!value[css]) {\n            ;(el as HTMLElement).style[css] = null\n          }\n        }\n      }\n    } else {\n      removeAttribute(el, 'style')\n    }\n  }\n}\n\nexport function patchProp(\n  el: Element,\n  key: string,\n  vnode: VNode,\n  oldValue?: any,\n  newValue?: any,\n  debugOption?: DebugOption\n) {\n  if (isEventProps(key)) {\n    patchEvent(el, normalizeEventName(key), oldValue, newValue, debugOption)\n  } else if (key === 'style') {\n    patchStyle(el, oldValue, newValue, vnode, debugOption)\n  } else if (key === 'class' || key === 'className') {\n    patchClass(el, oldValue, newValue, debugOption)\n  } else if (key === 'html') {\n    if (shouldValue(vnode.children)) {\n      console.warn(\n        'Both the html attribute and the child node exist in the node.\\n',\n        vnode\n      )\n    } else {\n      // completely re-render the child element, throwing a warning when the child element is not empty.\n      el.innerHTML = newValue\n    }\n  } else {\n    try {\n      setAttribute(el, key, newValue, vnode)\n    } catch (e) {\n      console.warn(e)\n    }\n  }\n}\n\nexport function mountProps(el: Element, vnode: VNode) {\n  for (const key in vnode.props) {\n    patchProp(el, key, vnode, null, vnode.props[key])\n  }\n}\n\nexport function patchProps(el: Element, n1: VNode, n2: VNode) {\n  const unmounts = []\n  for (const key in n2.props) {\n    unmounts.push(key)\n    const oldValue = n1.props?.[key]\n    const newValue = n2.props?.[key]\n    patchProp(el, key, n2, oldValue, newValue)\n  }\n\n  // remove old props\n  if (n1.props) {\n    unmountProps(\n      el,\n      keys(n1.props).filter((key) => !unmounts.includes(key)),\n      n1.props\n    )\n  }\n}\n", "import { isFunction, isString } from '@gyron/shared'\nimport { querySelector } from '@gyron/dom-client'\nimport { ComponentSetupFunction } from './component'\nimport {\n  VNode,\n  Text,\n  Element,\n  Comment,\n  Fragment,\n  Gyron,\n  NodeType,\n} from './vnode'\n\n/**\n * Determine if the incoming parameter is a virtual node\n * ```js\n * import { isVNode, h } from 'gyron'\n *\n * const App = h(() => {\n *   return h('div', 'async anchor')\n * })\n *\n * isVNode(App) // true\n * ```\n * @api global\n * @returns boolean\n */\nexport function isVNode(n: any): n is VNode {\n  return n && n.flag === Gyron\n}\n\nexport function isVNodeElement(n: VNode): n is VNode<typeof Element> {\n  return n.type === Element\n}\n\nexport function isVNodeText(n: VNode): n is VNode<typeof Text> {\n  return n.type === Text\n}\n\nexport function isVNodeComment(n: VNode): n is VNode<typeof Comment> {\n  return n.type === Comment\n}\n\nexport function isVNodeFragment(n: VNode): n is VNode<typeof Fragment> {\n  return n.type === Fragment\n}\n\n/**\n * Determine if the incoming parameter is a component node\n * ```js\n * import { isVNodeComponent, h } from 'gyron'\n *\n * const App = h(() => {\n *   return h('div', 'async anchor')\n * })\n *\n * isVNodeComponent(App) // true\n * ```\n * @api global\n * @returns boolean\n */\nexport function isVNodeComponent(n: VNode): n is VNode<ComponentSetupFunction> {\n  return isVNode(n) && isFunction(n.type) && n.nodeType === NodeType.Component\n}\n\nexport function getUserContainer(containerOrSelector: string | Element) {\n  if (isString(containerOrSelector)) {\n    return querySelector(containerOrSelector)\n  } else {\n    return containerOrSelector\n  }\n}\n", "import { isVNode, isVNodeComponent } from './shared'\nimport {\n  extend,\n  isArray,\n  isFunction,\n  isString,\n  isUndefined,\n  omit,\n  shouldValue,\n} from '@gyron/shared'\nimport {\n  Component,\n  ComponentDefaultProps,\n  ComponentFunction,\n  ComponentSetupFunction,\n} from './component'\nimport { UserRef } from './ref'\nimport { TransitionHooks } from './Transition'\n\nexport const Gyron = Symbol('gyron')\nexport const Text = Symbol('gyron.text')\nexport const Element = Symbol('gyron.element')\nexport const Comment = Symbol('gyron.comment')\nexport const Fragment = Symbol('gyron.fragment')\n\ntype ToUpper<T extends string> = T extends `${infer F}${infer Rest}`\n  ? `${Uppercase<F>}${Rest}`\n  : never\n\ntype ToLower<T extends string> = T extends `${infer F}${infer Rest}`\n  ? `${Lowercase<F>}${Rest}`\n  : never\n\ntype APrefixEvent<K extends string, P extends string> = K extends string\n  ? `${P}${ToUpper<K>}`\n  : never\n\ntype RPrefixEvent<\n  K extends string,\n  P extends string\n> = K extends `${P}${infer Key}` ? ToLower<Key> : never\n\ntype Prefix = 'on'\n\nexport type VNodeEvent = {\n  [Key in APrefixEvent<keyof HTMLElementEventMap, Prefix>]?: (\n    e: HTMLElementEventMap[RPrefixEvent<Key, Prefix>]\n  ) => any\n}\n\nexport enum NodeType {\n  Fragment = -2,\n  Component = -1,\n  Element = 1,\n  Text = 3,\n  Comment = 8,\n}\n\nexport type TextContent = string | number | boolean | null | undefined\nexport type Children = VNode | TextContent\nexport type VNodeChildren = Children | Children[]\n\nexport interface VNodeDefaultProps {\n  ref: UserRef\n  key: string | number\n}\n\nexport interface RenderElement extends Node {\n  [key: string]: any\n  __vnode__?: VNode\n}\n\nexport type VNodeType =\n  | string\n  | VNode\n  | Component\n  | ComponentFunction<any>\n  | ComponentSetupFunction<any>\n  | typeof Text\n  | typeof Element\n  | typeof Comment\n  | typeof Fragment\n\nexport interface VNode<\n  T extends VNodeType = VNodeType,\n  P extends VNodeProps = VNodeProps\n> {\n  flag: symbol\n  type: T\n  nodeType: NodeType\n  props: Partial<P>\n  el?: RenderElement\n  // true flag bits to ensure accurate position when inserting elements\n  anchor?: RenderElement\n  key?: number | string | symbol\n  // parent vnode\n  parent?: VNode\n  tag?: string\n  is?: any\n  component?: Component\n  // children node\n  children?: VNodeChildren\n  transition?: TransitionHooks\n  // development hydrate component uri\n  __uri?: string\n}\n\nexport interface VNodeProps extends VNodeEvent, ComponentDefaultProps {\n  [k: string]: any\n}\n\n/**\n * Clone the `VNode` node.\n * ```js\n * import { createComment, cloneVNode, h } from 'gyron'\n *\n * const App = h(() => {\n *   return createComment('async anchor')\n * })\n *\n * App !== cloneVNode(App) // true\n * ```\n * @api global\n * @param vnode The node to be copied, or it can be a normal value.\n * @returns Nodes after cloning.\n */\nexport function cloneVNode<T extends VNode | VNode[]>(vnode: T): T {\n  if (isArray(vnode)) {\n    return vnode.map(cloneVNode) as T\n  }\n\n  if (isVNode(vnode)) {\n    return extend({}, vnode, {\n      flag: Gyron,\n    })\n  }\n\n  return normalizeVNode(vnode) as T\n}\n\n/**\n * Merge `props` to the target node.\n * ```javascript\n * import { createComment, mergeVNode, h } from 'gyron'\n *\n * const Child = h(() => {\n *   return createComment('async anchor')\n * })\n *\n * const App = mergeVNode(Child, { class: 'container' })\n * App.props.class === 'container' // true\n * ```\n * @api global\n * @param vnode Nodes that need to be merged.\n * @param props The attributes to be copied to the node.\n * @returns Returns the merged node.\n */\nexport function mergeVNode<T extends VNode | VNode[]>(\n  vnode: T,\n  props: Partial<VNodeProps>\n): T {\n  if (isArray(vnode)) {\n    for (let i = 0; i < vnode.length; i++) {\n      const node = normalizeVNode(vnode[i])\n      vnode[i] = node\n      mergeVNode(node, props)\n    }\n  } else {\n    extend(vnode.props, props)\n  }\n  return vnode\n}\n\nexport function mergeVNodeWith(n1: VNode, n2: VNode) {\n  if (isVNodeComponent(n1) && isVNodeComponent(n2)) {\n    n1.component = n2.component\n  }\n  n1.el = n2.el\n  return n1\n}\n\nexport function createVNode(\n  tag: unknown,\n  props?: Partial<VNodeProps>,\n  children?: VNodeChildren\n): VNode {\n  let vnodeProps = props ? props : {}\n\n  const key = shouldValue(vnodeProps.key) ? vnodeProps.key : null\n  let type: VNodeType = Text\n  let nodeType: NodeType = NodeType.Text\n  let _uri: string\n\n  if (isString(tag) && (!isUndefined(props) || !isUndefined(children))) {\n    type = Element\n    nodeType = NodeType.Element\n  } else if (isFunction(tag)) {\n    type = tag\n    nodeType = NodeType.Component\n    vnodeProps = omit(vnodeProps, 'key')\n\n    // ssr mode merge context to props\n    const __ssr_uri = (tag as ComponentSetupFunction).__ssr_uri\n    if (__ssr_uri) {\n      _uri = __ssr_uri\n    }\n  } else if (isArray(tag)) {\n    type = Fragment\n    nodeType = NodeType.Fragment\n    children = mergeVNode(tag.map(normalizeVNode), vnodeProps)\n  } else {\n    children = tag as TextContent\n  }\n\n  if (isArray(children)) {\n    children = children.flat(Infinity)\n  }\n\n  const vnode: VNode = {\n    type: type,\n    nodeType: nodeType,\n    key: key,\n    flag: Gyron,\n    props: vnodeProps,\n    children: children,\n    __uri: _uri,\n  }\n\n  if (type === Element) {\n    vnode.tag = tag as string\n  }\n  return vnode\n}\n\nexport function createVNodeComment(children?: string): VNode<typeof Comment> {\n  return {\n    type: Comment,\n    nodeType: NodeType.Comment,\n    props: {},\n    flag: Gyron,\n    children: children,\n  }\n}\n\nexport function normalizeVNode(value: VNodeChildren): VNode {\n  if (isVNode(value)) {\n    return value\n  }\n  if (value === null || typeof value === 'boolean') {\n    return createVNodeComment()\n  }\n  if (Array.isArray(value)) {\n    return createVNode(value.slice() as VNode[])\n  }\n  return createVNode('' + value)\n}\n\nexport function normalizeChildrenVNode(vnode: VNode) {\n  const parent: VNode = vnode\n\n  if (!parent) {\n    console.warn(\n      'The parent node was not found when formatting the child node, this will raise a PROVIDE error, please check.'\n    )\n  }\n\n  const children = isArray(vnode.children) ? vnode.children : [vnode.children]\n\n  return children\n    .filter(shouldValue)\n    .map((node) => normalizeVNodeWithLink(node, parent))\n}\n\nexport function normalizeVNodeWithLink(children: Children, parent: VNode) {\n  const node = normalizeVNode(children)\n  node.parent = parent\n  return node\n}\n", "import type { Component } from './component'\nimport { initialLifecycle, isBoolean } from '@gyron/shared'\nimport {\n  getCurrentComponent,\n  callWithErrorHandling,\n  ErrorHandlingType,\n} from './component'\n\ntype LifecycleCallback = (component: Component) => any\ntype LifecycleUpdateCallback<T = any> = (\n  prevProps: T,\n  props?: T\n) => void | boolean\n\nexport type Lifecycle = Partial<{\n  beforeMounts: Set<LifecycleCallback>\n  afterMounts: Set<LifecycleCallback>\n  destroyed: Set<LifecycleCallback>\n  beforeUpdates: Set<LifecycleUpdateCallback>\n  afterUpdates: Set<LifecycleUpdateCallback>\n}>\n\nfunction wrapLifecycle(component: Component, type: keyof Lifecycle) {\n  if (!component.lifecycle || !component.lifecycle[type]) return\n\n  const lifecycle = [...component.lifecycle[type]]\n  const wrapResult = []\n\n  for (let i = 0; i < lifecycle.length; i++) {\n    const listener = lifecycle[i]\n    const params = []\n    if (type === 'beforeUpdates' || type === 'afterUpdates') {\n      params.push(component.prevProps, component.props)\n    } else {\n      params.push(component)\n    }\n    const result = callWithErrorHandling(\n      listener,\n      component,\n      ErrorHandlingType.Lifecycle,\n      params\n    )\n\n    if (type === 'beforeUpdates' && isBoolean(result) && !result) {\n      return false\n    }\n\n    wrapResult.push(result)\n  }\n\n  return wrapResult\n}\n\n/**\n * Lifecycle hooks, register a callback function that is called before the component is rendered.\n * ```js\n * import { h, onBeforeMount } from 'gyron'\n *\n * const App = h(() => {\n *   onBeforeMount((component) => {\n *     component // self\n *   })\n *   return h('div', 'hello world')\n * })\n * ```\n * @api component\n * @param callback Callback function.\n */\nexport function onBeforeMount(callback: LifecycleCallback) {\n  const component = getCurrentComponent()\n  initialLifecycle(component, 'beforeMounts')\n  component.lifecycle.beforeMounts.add(callback)\n}\n\n/**\n * Life cycle hooks, register a callback function to be called after the component has been rendered,\n * where you can get the real DOM information in the callback function.\n * ```js\n * import { h, onAfterMount } from 'gyron'\n *\n * const App = h(() => {\n *   onAfterMount((component) => {\n *     component.$el // HTMLDivElement\n *   })\n *   return h('div', 'hello world')\n * })\n * ```\n * @api component\n * @param callback Callback function.\n */\nexport function onAfterMount(callback: LifecycleCallback) {\n  const component = getCurrentComponent()\n  initialLifecycle(component, 'afterMounts')\n  component.lifecycle.afterMounts.add(callback)\n}\n\n/**\n * Lifecycle hook to register a callback function to be called after the component has been destroyed.\n * ```js\n * import { h, onDestroyed } from 'gyron'\n *\n * const App = h(() => {\n *   const timer = setInterval(() => {\n *     console.log(Date.now())\n *   }, 1000)\n *   onDestroyed((component) => {\n *     clearInterval(timer)\n *   })\n *   return h('div', 'hello world')\n * })\n * ```\n * @api component\n * @param callback Callback function.\n */\nexport function onDestroyed(callback: LifecycleCallback) {\n  const component = getCurrentComponent()\n  initialLifecycle(component, 'destroyed')\n  component.lifecycle.destroyed.add(callback)\n}\n\n/**\n * Lifecycle hooks that register a callback function to be called before the component is updated.\n * Returning `Falsy` prevents updates to itself and sub components.\n * ```js\n * import { h, onBeforeUpdate } from 'gyron'\n *\n * const App = h(() => {\n *   onBeforeUpdate((prevProps, props) => {\n *     return false // The view will not be updated even when changes occur\n *   })\n *   return h('div', 'hello world')\n * })\n * ```\n * @api component\n * @param callback Callback function.\n */\nexport function onBeforeUpdate<T extends object>(\n  callback: LifecycleUpdateCallback<T>\n) {\n  const component = getCurrentComponent()\n  initialLifecycle(component, 'beforeUpdates')\n  component.lifecycle.beforeUpdates.add(callback)\n}\n\n/**\n * Lifecycle hooks, register a callback function that is called before the component is rendered.\n * ```js\n * import { h, onAfterUpdate } from 'gyron'\n *\n * const App = h(() => {\n *   onAfterUpdate((prevProps, props) => {\n *     component // self\n *   })\n *   return h('div', 'hello world')\n * })\n * ```\n * @api component\n * @param callback Callback function.\n */\nexport function onAfterUpdate(callback: LifecycleUpdateCallback) {\n  const component = getCurrentComponent()\n  initialLifecycle(component, 'afterUpdates')\n  component.lifecycle.afterUpdates.add(callback)\n}\n\nexport function invokeLifecycle(component: Component, type: keyof Lifecycle) {\n  switch (type) {\n    case 'beforeMounts':\n    case 'afterMounts':\n    case 'destroyed':\n    case 'beforeUpdates':\n    case 'afterUpdates':\n      return wrapLifecycle(component, type)\n  }\n}\n", "import { Component, getCurrentComponent } from './component'\nimport { getErrorBoundaryCtx } from './ErrorBoundary'\n\nexport type BoundariesHandlerParamsType = 'Error' | 'Warn'\nexport type BoundariesHandlerParams = Partial<{\n  message: string\n  component: Component\n  stack: string\n  type: BoundariesHandlerParamsType\n}>\nexport type BoundariesHandler = (params: BoundariesHandlerParams) => void\n\nexport const ErrorType = Symbol.for('gyron.error-handler')\nexport const WarnType = Symbol.for('gyron.warn-handler')\n\n/**\n * Register an event listener for errors and the registered callback function\n * will be executed when an error occurs in the component.\n * ```js\n * import { registerErrorHandler, h } from 'gyron'\n * const App = h(() => {\n *   registerErrorHandler(({ message }) => {\n *     message // Uncaught exceptions\n *   })\n *   throw new Error('Uncaught exceptions')\n * })\n * ```\n * @api boundaries\n * @param handler Handling functions.\n */\nexport function registerErrorHandler(handler: BoundariesHandler) {\n  const component = getCurrentComponent()\n  component.ctx[ErrorType] = handler\n}\n\n/**\n * Register an event listener for warnings, the registered callback function\n * will be executed when a warning occurs on the component.\n * ```js\n * import { registerWarnHandler, useInject, h } from 'gyron'\n *\n * const App = h(() => {\n *   registerWarnHandler(({ message }) => {\n *     message // Contextual information not obtained ...\n *   })\n *   useInject()('a')\n *   return h('div', 'hello world')\n * })\n *```\n * @api boundaries\n * @param handler Handling functions.\n */\nexport function registerWarnHandler(handler: BoundariesHandler) {\n  const component = getCurrentComponent()\n  component.ctx[WarnType] = handler\n}\n\nfunction manualHandlerBase(\n  type: BoundariesHandlerParamsType,\n  error: Error | unknown,\n  component: Component\n) {\n  if (!component) {\n    console.warn(\n      'No component instance found, you can get { component } on the component parameter'\n    )\n    return null\n  }\n  const componentHandle = component.ctx[type === 'Error' ? ErrorType : WarnType]\n  const handler = (componentHandle ||\n    getErrorBoundaryCtx(component)) as BoundariesHandler\n  if (!handler) {\n    console.warn(\n      'No ErrorBoundary component was found in the upper level component, please register the ErrorBoundary component and try again.'\n    )\n    return null\n  }\n  if (error instanceof Error) {\n    handler({\n      type: type,\n      message: error.message,\n      component: component,\n      stack: error.stack,\n    })\n  } else {\n    handler({ type: type, message: String(error), component: component })\n  }\n}\n\n/**\n * Proactive triggering of event callbacks registered via the registerErrorHandler method.\n * ```js\n * import { manualErrorHandler, h } from 'gyron'\n *\n * const App = h(() => {\n *   Promise.reject('Error: Uncaught exceptions').catch((e) => {\n *     manualErrorHandler(e, component)\n *   })\n *   return h('div', 'hello world')\n * })\n * ```\n * @api boundaries\n * @param error Error log message\n * @param component The component instance, which can be obtained via the second parameter of the component function.\n */\nexport function manualErrorHandler(\n  error: Error | unknown,\n  component: Component\n) {\n  return manualHandlerBase('Error', error, component)\n}\n\n/**\n * Proactive triggering of event callbacks registered via the registerWarnHandler method\n * ```js\n * import { manualWarnHandler, h } from 'gyron'\n *\n * const App = h(() => {\n *   manualWarnHandler('Warn: performance is not defined', component)\n *   return h('div', 'hello world')\n * })\n * ```\n * @api boundaries\n * @param warn Warning log message.\n * @param component The component instance, which can be obtained via the second parameter of the component function.\n */\nexport function manualWarnHandler(warn: string, component: Component) {\n  return manualHandlerBase('Warn', warn, component)\n}\n", "import { Component } from './component'\nimport { getErrorBoundaryCtx } from './ErrorBoundary'\nimport { ErrorType, WarnType, BoundariesHandler } from './boundaries'\n\nexport enum InnerCode {\n  Transition = 1000,\n}\n\nexport function warn(\n  err: Error | string,\n  component: Component | null,\n  type: string\n) {\n  if (component && component.ctx[WarnType]) {\n    const errorHandler = component.ctx[WarnType] as BoundariesHandler\n    if (err instanceof Error) {\n      errorHandler({\n        type: 'Warn',\n        message: err.message,\n        component: component,\n        stack: err.stack,\n      })\n    } else {\n      errorHandler({\n        type: 'Warn',\n        message: err,\n        component: component,\n        stack: null,\n      })\n    }\n  } else {\n    console.warn(`[${type}]`, err, '\\n', component)\n  }\n}\n\nexport function error(err: Error, component: Component | null, type: string) {\n  if (component) {\n    let errorHandler: BoundariesHandler\n    if (component.ctx[ErrorType]) {\n      errorHandler = component.ctx[ErrorType] as BoundariesHandler\n    }\n    if (!errorHandler) {\n      errorHandler = getErrorBoundaryCtx(component) as BoundariesHandler\n    }\n    if (errorHandler) {\n      errorHandler({\n        type: 'Error',\n        message: err.message,\n        component: component,\n        stack: err.stack,\n      })\n      return null\n    }\n  }\n  console.error(`[${type}]`, err, '\\n', component)\n}\n", "import {\n  useReactive,\n  useEffect,\n  Dependency,\n  Effect,\n  EffectFunction,\n} from '@gyron/reactivity'\nimport {\n  extend,\n  isFunction,\n  isObject,\n  isPromise,\n  isUndefined,\n  omit,\n} from '@gyron/shared'\nimport {\n  createVNodeComment,\n  VNode,\n  VNodeType,\n  normalizeVNode,\n  RenderElement,\n  VNodeProps,\n  cloneVNode,\n  VNodeChildren,\n} from './vnode'\nimport { SchedulerJob } from './scheduler'\nimport { invokeLifecycle, Lifecycle, onDestroyed } from './lifecycle'\nimport { error, warn } from './assert'\nimport { UserRef } from './ref'\n\nexport type UtilComponentProps<T extends VNodeType, D = never> = T extends\n  | ComponentFunction<infer Props>\n  | ComponentSetupFunction<infer Props>\n  ? Props & Omit<ComponentDefaultProps, 'isSSR'>\n  : D\n\nexport type ComponentDefaultProps = Partial<{\n  readonly isSSR: boolean\n  readonly children: VNodeChildren\n  readonly key: string | number | symbol\n  readonly ref: UserRef\n  // Used in loop nodes to determine if updates to props occur and thus decide whether to skip updates to child nodes.\n  readonly memo: any[]\n  // The user can optionally mark a node as static and all subsequent updates will skip the marked node.\n  readonly static: boolean\n  // Used for server-side rendering and client-side rendering to render text as real nodes.\n  readonly html: string\n}>\n\nexport type ComponentFunction<Props extends object = object> = (\n  props?: Props & ComponentDefaultProps,\n  component?: Component<Props>\n) => VNodeChildren\n\nexport interface ComponentSetupFunction<Props extends object = object> {\n  (props: Props & ComponentDefaultProps, component: Component<Props>):\n    | (VNodeChildren | Promise<VNodeChildren>)\n    | ComponentFunction<Props>\n  __cache?: boolean\n  __cacheIndex?: number\n  __ssr_uri?: string\n  __hmr_id?: string\n  [k: string]: any\n}\n\nexport type AsyncComponentFunction<Props extends object = object> = (\n  props: AsyncProps<Props>\n) => Promise<ComponentSetupFunction<Props> | VNode>\n\ntype AsyncProps<Props> = Props & ComponentDefaultProps & { fallback?: VNode }\n\ntype AsyncComponentFunctionReturn<Props extends object = object> = {\n  (): Promise<VNode>\n  readonly __loader: (\n    props: AsyncProps<Props>,\n    component: Component\n  ) => Promise<VNode<VNodeType>>\n}\n\nexport type WrapperFunction<Props extends object> = {\n  (\n    props: Omit<Props, keyof ComponentDefaultProps>,\n    component: Component<Props>\n  ): VNode\n}\n\nexport type Exposed = Record<string | number, any>\n\nexport interface Component<T extends object = object> {\n  uid: number\n  mounted: boolean\n  destroyed: boolean\n  parent: Component\n  subTree: VNode\n  vnode: VNode<ComponentSetupFunction>\n  type: ComponentSetupFunction\n  effect: Effect\n  update: SchedulerJob\n  render: ComponentFunction<T>\n  setup: ComponentSetupFunction\n  props: T & ComponentDefaultProps\n  prevProps: T & ComponentDefaultProps\n  ctx: Record<string | symbol, unknown>\n  lifecycle: Lifecycle\n  exposed: Exposed\n  $el: RenderElement\n  $parent: RenderElement\n}\n\nlet uid = 0\nlet _component: Component\n\nexport function createComponentInstance(\n  vnode: VNode<ComponentSetupFunction>,\n  parentComponent: Component | null\n): Component {\n  const component: Component = {\n    uid: uid++,\n    type: vnode.type,\n    parent: null,\n    vnode: null,\n    ctx: {},\n    mounted: false,\n    destroyed: false,\n    subTree: null,\n    effect: null,\n    update: null,\n    render: null,\n    setup: null,\n    props: null,\n    prevProps: null,\n    lifecycle: null,\n    exposed: null,\n    $el: null,\n    $parent: null,\n  }\n  normalizeComponent(vnode, component, parentComponent)\n  return component\n}\n\n/**\n * Get the current component object, but do not change or delete the values in it, as unintended errors may occur.\n * ```js\n * import { h, getCurrentComponent } from 'gyron'\n *\n * const App = h(() => {\n *   const component = getCurrentComponent()\n *   return h('div', 'hello world')\n * })\n * ```\n * @api component\n * @returns Component\n */\nexport function getCurrentComponent() {\n  if (!_component) {\n    warn(\n      'Failed to get component instance, please submit issues to us at https://github.com/gyronorg/core',\n      null,\n      'getCurrentComponent'\n    )\n  }\n  return _component\n}\n\nexport function forceUpdate(component: Component) {\n  component.update()\n}\n\nfunction renderComponentSubTree(\n  component: Component,\n  props: VNodeProps,\n  renderTree: ReturnType<ComponentSetupFunction<VNodeProps>>\n) {\n  if (isFunction(renderTree)) {\n    component.render = renderTree\n    renderTree = callWithErrorHandling(\n      renderTree,\n      component,\n      ErrorHandlingType.Setup,\n      [props, component]\n    ) as VNodeChildren\n  }\n  if (isPromise(renderTree)) {\n    return renderTree.then((subTree: VNodeChildren) => {\n      subTree = normalizeVNode(subTree)\n      subTree.parent = component.vnode\n      return subTree\n    })\n  }\n\n  const subTree = normalizeVNode(renderTree)\n  subTree.parent = component.vnode\n  return subTree\n}\n\nexport function renderComponent(component: Component, isSSR = false) {\n  const { render, setup } = component\n\n  const renderFunction = render || setup\n\n  // getCurrentComponent fn return current\n  _component = component\n  const props = normalizeComponentProps(component, isSSR)\n  const renderTree: ReturnType<ComponentSetupFunction<VNodeProps>> =\n    callWithErrorHandling(\n      renderFunction,\n      component,\n      render ? ErrorHandlingType.Render : ErrorHandlingType.Setup,\n      [props, component]\n    )\n  _component = null\n\n  if (!component.mounted) {\n    // onBeforeMount\n    invokeLifecycle(component, 'beforeMounts')\n  }\n\n  return renderComponentSubTree(component, props, renderTree)\n}\n\n/**\n * The defineProps method cannot declare its return value using the deconstruction syntax\n *\n * correct code:\n * ```js\n * const props = defineProps()\n * props.foo\n * ```\n *\n * ~~incorrect code:~~\n * ```js\n * const { foo } = defineProps()\n * ```\n * @api component\n */\nexport function defineProps<\n  T extends object,\n  R extends object = T & ComponentDefaultProps\n>(defaultValue?: object) {\n  const component = getCurrentComponent()\n  if (isObject(defaultValue)) {\n    const props = extend({}, component.props)\n    for (const key in defaultValue) {\n      if (isUndefined(component.props[key])) {\n        props[key] = defaultValue[key]\n      }\n    }\n    return props as R\n  }\n  return component.props as R\n}\n\n/**\n * Exposes the data in the component for use by the parent component.\n * ```js\n * import { h, useValue, createRef, exposeComponent } from 'gyron'\n *\n * const Child = h(() => {\n *   const name = useValue('foo')\n *\n *   exposeComponent({ name })\n *\n *   return h('div', null, name.value)\n * })\n *\n * const App = h(() => {\n *   const ref = createRef()\n *\n *   ref.current // {name: {value: 'foo'}}\n *\n *   return h(Child, { ref })\n * })\n * ```\n * @line 14\n * @api component\n * @param exposed object\n */\nexport function exposeComponent(exposed: Record<string | number, any>) {\n  const component = getCurrentComponent()\n  extend(component.exposed, exposed)\n}\n\n/**\n * Component wrapper for the useEffect method, which automatically destroys the current effect dependency when the component is destroyed\n *\n * ```js\n * useWatch(() => {\n *  if (loading.value) {\n *    console.log('loading')\n *  }\n * })\n * ```\n *\n * Or you can use the second argument to automatically load a dependency that you don't need to use in the function, but pass the second argument if you need to make changes based on the dependency.\n *\n * ```js\n * useWatch(() => {\n *  if (loading.value) {\n *    console.log('loading')\n *  }\n * }, [() => changed.value])\n * ```\n * @api component\n */\nexport function useWatch<T = any>(\n  watcher: EffectFunction<T>,\n  dependency?: Dependency[]\n) {\n  const { effect } = useEffect(watcher, dependency)\n  onDestroyed(() => effect.stop())\n}\n\nexport function isAsyncComponent(\n  componentFunction: any\n): componentFunction is AsyncComponentFunctionReturn {\n  return componentFunction ? isFunction(componentFunction.__loader) : false\n}\n\n/**\n * Wrapping functions for asynchronous components, providing fallback solutions,\n * support for scenarios such as asynchronous import of packaging tools.\n * ```ts\n * import { FCA } from 'gyron'\n *\n * interface Props {\n *   count: number\n * }\n *\n * const Child = FCA<Props>(() => import('./Son'))\n *\n * export const App = FC(() => {\n *   return <Child fallback={<span>loading...</span>} count={1} />\n * })\n *```\n * @api component\n * @param componentAsyncFunction function\n * @returns function\n */\nexport function FCA<\n  Props extends object = object,\n  T extends AsyncComponentFunction<Props> = AsyncComponentFunction<Props>\n>(componentAsyncFunction: T) {\n  let resolveComp: VNode\n  let setup: ComponentFunction<Props>\n  let loadedRet = false\n  let __component: Component\n\n  const state = useReactive({\n    loaded: false,\n  })\n\n  function setComponent(component: Component) {\n    _component = __component = component\n  }\n\n  function clearComponent() {\n    _component = null\n  }\n\n  const load = (props: AsyncProps<Props>, component: Component) => {\n    setComponent(component)\n    return componentAsyncFunction(props)\n      .then((value) => {\n        loadedRet = true\n        const subtree = ((value as { default?: ComponentFunction<Props> })\n          .default || value) as ComponentFunction<Props>\n\n        setComponent(component)\n        if (isFunction(subtree)) {\n          setup = subtree\n          resolveComp = normalizeVNode(\n            subtree(props, component as Component<Props>)\n          )\n        } else {\n          resolveComp = normalizeVNode(subtree as VNode)\n          if (__DEV__ && __WARN__) {\n            console.warn(\n              'Async components are recommended to return a function that updates local state.\\n' +\n                'It is different from normal components, normal components are called again, ' +\n                'while asynchronous components are called only once'\n            )\n          }\n        }\n        clearComponent()\n        return resolveComp\n      })\n      .catch((e) => {\n        error(e, component, 'AsyncComponent')\n        return createVNodeComment('AsyncComponentError')\n      })\n  }\n\n  const ret = function AsyncComponentWrapper() {\n    const props = defineProps<AsyncProps<Props>>()\n\n    if (props.isSSR) {\n      // used during server-side rendering\n      // where you need to wait for the asynchronous function to complete and return the html stream to the browser\n      return load(props, _component)\n    }\n\n    if (!loadedRet) {\n      load(props, _component).then(() => {\n        state.loaded = true\n      })\n    } else {\n      state.loaded = true\n    }\n\n    exposeComponent({\n      state: state,\n      __loader: load,\n    })\n\n    return function AsyncComponentWrapperSetup() {\n      _component = __component\n      return state.loaded && resolveComp\n        ? setup\n          ? setup(props)\n          : cloneVNode(resolveComp)\n        : props.fallback || createVNodeComment('AsyncComponentWrapper')\n    }\n  }\n\n  ret.__loader = load\n\n  return ret as unknown as WrapperFunction<AsyncProps<Props>>\n}\n\n/**\n * Define a component that is primarily used for type derivation in typescript\n * ```ts\n * import { FC } from 'gyron'\n * interface Props {\n *   count: number\n * }\n *\n * const Child = FC<Props>(() => {\n *   return ({ count }) => <span>{count}</span>\n * })\n *\n * export const App = FC(() => {\n *   return <Child count={1} />\n * })\n * ```\n * @api component\n * @param componentFunction function\n * @returns function\n */\nexport function FC<\n  Props extends object = object,\n  T extends ComponentSetupFunction<Props> = ComponentSetupFunction<Props>\n>(componentFunction: T) {\n  return componentFunction as WrapperFunction<Props>\n}\n\n/**\n * Create a cache component, and memo will automatically call the FC method to ensure that the component type can be correctly inferred\n */\nconst cacheMemoComponent = new Map<ComponentSetupFunction, Component>()\nlet cacheIndex = 0\n\nexport function getCacheComponent(componentFunction: ComponentSetupFunction) {\n  return cacheMemoComponent.get(componentFunction)\n}\n\nexport function collectCacheComponent(\n  componentFunction: ComponentSetupFunction,\n  component: Component\n) {\n  cacheMemoComponent.set(componentFunction, component)\n}\n\nexport function isCacheComponent(componentFunction: ComponentSetupFunction) {\n  return cacheMemoComponent.has(componentFunction)\n}\n\n/**\n * Pass in the component function to clear the component cache.\n * ```js\n * import { h, keepComponent, clearCacheComponent } from 'gyron'\n *\n * const App = keepComponent(() => {\n *   return h('div')\n * })\n *\n * clearCacheComponent(App)\n * ```\n * @api component\n * @line 7\n * @param componentFunction function\n */\nexport function clearCacheComponent(componentFunction: ComponentSetupFunction) {\n  if (isCacheComponent(componentFunction)) {\n    const component = cacheMemoComponent.get(componentFunction)\n    component.effect.stop()\n    cacheMemoComponent.delete(componentFunction)\n  }\n}\n\n/**\n * A cached component is created and the state of the component can be retained at all times.\n * The component cache can be cleared using `clearCacheComponent`.\n * ```javascript\n * import { h, keepComponent } from 'gyron'\n *\n * const App = keepComponent(() => {\n *   return h('div')\n * })\n * ```\n * @api component\n * @param componentFunction function\n * @returns function\n */\nexport function keepComponent<\n  Props extends object = object,\n  T extends ComponentSetupFunction<Props> = ComponentSetupFunction<Props>\n>(componentFunction: T) {\n  // TODO LRU\n  // if (cacheMemoComponent.size > 0x20) {\n  //   const f = cacheMemoComponent.keys()\n  //   for (const fc of f) {\n  //     if (cacheMemoComponent.size - 0x20 > fc.__cacheIndex) {\n  //       clearCacheComponent(fc)\n  //     }\n  //   }\n  // }\n  componentFunction.__cache = true\n  componentFunction.__cacheIndex = cacheIndex++\n  return componentFunction as WrapperFunction<Props>\n}\n\nexport enum ErrorHandlingType {\n  Render = 'Render',\n  Setup = 'Setup',\n  Lifecycle = 'Lifecycle',\n  Scheduler = 'Scheduler',\n}\n\nexport function callWithErrorHandling(\n  fn: (...args: any[]) => any | Promise<any>,\n  instance: Component | null,\n  type: ErrorHandlingType,\n  args?: unknown[]\n) {\n  let res: any\n  try {\n    res = args ? fn(...args) : fn()\n  } catch (err) {\n    error(err, instance, type)\n  }\n  return res\n}\n\nexport function normalizeComponent(\n  vnode: VNode<ComponentSetupFunction>,\n  component: Component,\n  parentComponent?: Component\n) {\n  const { type } = vnode\n\n  if (!type) {\n    console.warn('Failed to format component, \"type\" not found. node: ', vnode)\n    return\n  }\n\n  let setup: ComponentSetupFunction\n  if (isFunction(type)) {\n    setup = type\n  }\n\n  if (!component.props) {\n    component.props = {}\n  }\n\n  component.prevProps = extend({}, component.props)\n  component.props = extend(component.props, vnode.props, {\n    children: vnode.children,\n  })\n  component.exposed = component.exposed || {}\n  component.vnode = vnode\n  component.parent = parentComponent || component.parent\n  component.setup = setup || component.setup\n  component.type = type\n\n  if (type.__cache && !isCacheComponent(type)) {\n    collectCacheComponent(type, component)\n  }\n}\n\nexport function normalizeComponentProps(\n  component: Component,\n  isSSR: boolean\n): VNodeProps {\n  const builtinProps: ComponentDefaultProps = {\n    children: component.vnode.children,\n    isSSR: isSSR,\n  }\n\n  const props = extend<VNodeProps>(component.props, builtinProps)\n\n  return props\n}\n\nexport function removeBuiltInProps(props: Partial<VNodeProps>) {\n  const propsClone: ComponentDefaultProps = extend({}, props)\n  return omit(propsClone, ['isSSR', 'children', 'ref', 'key', 'memo', 'static'])\n}\n", "import { merge, extend, isPlanObject, isString } from '@gyron/shared'\nimport { isVNode } from './shared'\nimport {\n  VNodeChildren,\n  createVNode,\n  VNode,\n  VNodeProps,\n  VNodeType,\n} from './vnode'\nimport { UtilComponentProps } from './component'\n\nexport type HProps = VNodeProps | string\n\n/**\n * Creates a `VNode` node with a normal object return value.\n * Can be run directly in the browser and is mainly used to write applications in non-compiled environments.\n * ```js\n * import { h } from 'gyron'\n *\n * const App = h(() => {\n *   return h('div', 'hello world')\n * })\n * ```\n * @api global\n * @param type The type of node to be created, either a tag name or a function.\n * @param props Can be a string or an object, if it is a string it will be treated as `children`.\n * @param children A child node, either a VNode node or a string.\n * @returns VNode\n */\nexport function h<T extends VNodeType>(\n  type: T | T[],\n  props?: UtilComponentProps<T, HProps>,\n  children?: VNodeChildren\n): VNode {\n  if (!type) return\n\n  if (isString(props)) {\n    // h('div', 'hello world')\n    children = props\n    props = null\n  }\n\n  if (isVNode(type)) {\n    if (isPlanObject(props)) {\n      extend((type.props = type.props || {}), props)\n    }\n    type.children = merge<VNodeChildren>(type.children, children)\n    return type\n  }\n\n  return createVNode(type, props as VNodeProps, children)\n}\n", "import { warn } from './assert'\nimport { Component, getCurrentComponent } from './component'\n\nexport function provide(\n  component: Component,\n  name: string | symbol,\n  data: unknown\n) {\n  component.ctx[name] = data\n}\n\nexport function inject<T = unknown>(\n  component: Component,\n  name: string | symbol,\n  shouldWarn = true\n) {\n  let parentComponent = component.parent\n  while (parentComponent && !parentComponent.ctx[name]) {\n    parentComponent = parentComponent.parent\n  }\n  if (!parentComponent) {\n    if (shouldWarn) {\n      warn(\n        'Contextual information not obtained, key: ' + String(name),\n        component,\n        'inject'\n      )\n    }\n    return null\n  }\n  return parentComponent.ctx[name] as T\n}\n\n/**\n * Inject any data into all child components, either deep components or sibling components.\n * ```js\n * import { h, useProvide } from 'gyron'\n *\n * const App = h(() => {\n *   const provide = useProvide()\n *   provide('data', 0)\n *   return h('div', 'hello world')\n * })\n * ```\n * @api context\n */\nexport function useProvide<T = unknown>() {\n  const component = getCurrentComponent()\n  return (name: string | symbol, data: T) => provide(component, name, data)\n}\n\n/**\n * After the upper level component has used `useProvide`, the injected data is retrieved via `useInject`.\n * ```js\n * import { h, useInject } from 'gyron'\n *\n * const Child = h(() => {\n *   const inject = useInject()\n *   const data = inject('data') // 0\n *   return h('div', data)\n * })\n *\n * const App = h(() => {\n *   const provide = useProvide()\n *   provide('data', 0)\n *   return h(Child)\n * })\n * ```\n * @api context\n */\nexport function useInject() {\n  const component = getCurrentComponent()\n  return <T>(name: string | symbol) => inject<T>(component, name)\n}\n\n/**\n * Gets information about the `context` in the current component and contains the `provide` and `inject` functions.\n * ```javascript\n * import { h, useComponentContext } from 'gyron'\n *\n * const Child = h(() => {\n *   const context = useComponentContext()\n *   context['data'] // 0\n *   return h('div', 'child')\n * })\n *\n * const App = h(() => {\n *   const { context } = useComponentContext()\n *   context['data'] = 0\n *   return h(Child)\n * })\n * ```\n * @api context\n * @returns object\n */\nexport function useComponentContext() {\n  const component = getCurrentComponent()\n\n  return {\n    context: component.ctx,\n    provide: useProvide(),\n    inject: useInject(),\n  }\n}\n", "import { useReactive } from '@gyron/reactivity'\nimport { isFunction } from '@gyron/shared'\nimport { Component, FC } from './component'\nimport { VNode } from './vnode'\nimport { h } from './h'\nimport { inject, useProvide } from './context'\nimport { BoundariesHandler, BoundariesHandlerParams } from './boundaries'\n\nexport interface ErrorBoundaryProps {\n  fallback: VNode\n}\n\nexport function getErrorBoundaryCtx(component: Component) {\n  return inject(component, ErrorBoundaryType, false)\n}\n\nexport const ErrorBoundaryType = Symbol.for('gyron.error-boundary')\n\nexport const ErrorBoundary = FC<ErrorBoundaryProps>(function ErrorBoundary() {\n  const state = useReactive<{\n    error: boolean\n    payload: BoundariesHandlerParams\n  }>({\n    error: false,\n    payload: null,\n  })\n  // Inject error-catching code to give the user the ability to handle subComponents when an error occurs\n  useProvide<BoundariesHandler>()(\n    ErrorBoundaryType,\n    ({ type, message, component, stack }) => {\n      state[type.toLocaleLowerCase()] = true\n      state.payload = {\n        type,\n        message,\n        component,\n        stack,\n      }\n    }\n  )\n\n  return function ErrorBoundaryRender({ children, fallback }) {\n    return state.error\n      ? isFunction(fallback.type)\n        ? h(fallback, state.payload)\n        : fallback\n      : children\n  }\n})\n", "import { VNode } from './vnode'\nimport { FC } from './component'\nimport { isFunction, isNumber, shouldValue } from '@gyron/shared'\nimport { isVNode, isVNodeComment, RenderElement, warn } from '.'\nimport { Noop } from '@gyron/shared'\nimport { InnerCode } from './assert'\n\ninterface TransitionPropsNormalize {\n  cls: {\n    activeBefore: string\n    active: string\n    leaveBefore: string\n    leave: string\n  }\n  duration: { active: number; leave: number }\n}\n\nexport interface TransitionHooks {\n  state: ReturnType<typeof useTransitionState>\n  onActive: (el: Element) => void\n  onLeave: (el: Element, done: Noop) => void\n  onLeaveFinish: (el: Element) => void\n  // TODO for transition group\n  delayLeave?: (el: Element, done?: Noop) => void\n}\n\ntype Duration = number | { active: number; leave: number }\n\ntype TransitionState = ReturnType<typeof useTransitionState>\n\ntype TransitionElementMethod = '__remove__' | '__active__'\n\nexport interface TransitionProps {\n  name: string\n  activeBeforeClassName?: string\n  activeClassName?: string\n  leaveBeforeClassName?: string\n  leaveClassName?: string\n  duration?: Duration\n}\n\nfunction normalizedClassName(props: TransitionProps) {\n  return {\n    activeBefore: props.activeBeforeClassName || `${props.name}-active-before`,\n    active: props.activeClassName || `${props.name}-active`,\n    leaveBefore: props.leaveBeforeClassName || `${props.name}-leave-before`,\n    leave: props.leaveClassName || `${props.name}-leave`,\n  }\n}\n\nlet _uid = 0\nexport function whenTransitionEnd(\n  el: Element & { __uid__?: number },\n  duration: number | null,\n  done: Noop,\n  debugOptions?: {\n    transition: string\n  }\n) {\n  const id = (el.__uid__ = ++_uid)\n\n  function onEnd() {\n    el.removeEventListener('transitionend', onEnd)\n    if (el.__uid__ === id) {\n      // no less than 1 animation execution of the element occurs, and no callbacks are executed before\n      done()\n    }\n  }\n\n  if (isNumber(duration)) {\n    return setTimeout(onEnd, duration)\n  }\n\n  // check is element has transition\n  const transition = debugOptions\n    ? debugOptions.transition\n    : window.getComputedStyle(el).getPropertyValue('transition')\n  const hasTransition = transition !== 'all 0s ease 0s'\n\n  if (hasTransition) {\n    el.addEventListener('transitionend', onEnd)\n  } else {\n    onEnd()\n  }\n}\nfunction onAddClassName(el: Element, name: string) {\n  el.classList.add(name)\n}\nfunction onRemoveClassName(el: Element, name: string) {\n  el.classList.remove(name)\n}\nfunction onBeforeActiveHook(el: Element, props: TransitionPropsNormalize) {\n  onAddClassName(el, props.cls.activeBefore)\n}\nfunction onActiveHook(\n  el: Element,\n  props: TransitionPropsNormalize,\n  done: Noop\n) {\n  return requestAnimationFrame(() => {\n    onRemoveClassName(el, props.cls.activeBefore)\n    onAddClassName(el, props.cls.active)\n    whenTransitionEnd(el, props.duration?.active, done)\n  })\n}\nfunction onBeforeLeaveHook(el: Element, props: TransitionPropsNormalize) {\n  onAddClassName(el, props.cls.leaveBefore)\n}\nfunction onLeaveHook(el: Element, props: TransitionPropsNormalize, done: Noop) {\n  return requestAnimationFrame(() => {\n    onRemoveClassName(el, props.cls.leaveBefore)\n    onAddClassName(el, props.cls.leave)\n    whenTransitionEnd(el, props.duration?.leave, done)\n  })\n}\nfunction onActiveFinish(el: Element, props: TransitionPropsNormalize) {\n  onRemoveClassName(el, props.cls.activeBefore)\n  onRemoveClassName(el, props.cls.active)\n}\nfunction onLeaveFinish(el: Element, props: TransitionPropsNormalize) {\n  onRemoveClassName(el, props.cls.leaveBefore)\n  onRemoveClassName(el, props.cls.leave)\n}\n\nfunction normalizeTransitionProps(\n  props: TransitionProps\n): TransitionPropsNormalize {\n  function normalizeDuration(duration: Duration) {\n    if (isNumber(duration)) {\n      return {\n        active: duration,\n        leave: duration,\n      }\n    }\n    return duration\n  }\n  return {\n    cls: normalizedClassName(props),\n    duration: normalizeDuration(props.duration),\n  }\n}\n\nfunction useTransitionState() {\n  const leaveInnerNodes = new Map<\n    any,\n    Record<number | string | symbol, VNode>\n  >()\n  const activeInnerNodes = new Map<\n    any,\n    Record<number | string | symbol, VNode>\n  >()\n  return {\n    leaveInnerNodes,\n    activeInnerNodes,\n  }\n}\n\nfunction processFinish(\n  state: TransitionState,\n  vnode: VNode,\n  type: keyof TransitionState,\n  method: TransitionElementMethod\n) {\n  const n = state[type].get(vnode.type)\n  const n1 = n && n[vnode.key]\n  if (n1 && n1.el && n1.el[method]) {\n    const f = n1.el[method]\n    n1.el[method] = undefined\n    isFunction(f) && f()\n    delete n[vnode.key]\n  }\n}\n\nfunction setInnerVNode(\n  state: TransitionState,\n  vnode: VNode,\n  type: keyof TransitionState\n) {\n  const cache = state[type]\n  if (shouldValue(vnode.key)) {\n    if (cache.has(vnode.type)) {\n      const n = cache.get(vnode.type)\n      n[vnode.key] = vnode\n    } else {\n      cache.set(vnode.type, {\n        [vnode.key]: vnode,\n      })\n    }\n  } else if (__DEV__) {\n    warn(\n      `An exception has occurred, please submit error code ${InnerCode.Transition} to issue`,\n      vnode.component,\n      'Transition'\n    )\n  }\n}\n\nfunction generateTransitionHook(\n  vnode: VNode,\n  state: ReturnType<typeof useTransitionState>,\n  props: TransitionPropsNormalize\n): TransitionHooks {\n  return {\n    state: state,\n    onActive(el) {\n      processFinish(state, vnode, 'leaveInnerNodes', '__remove__')\n      setInnerVNode(state, vnode, 'activeInnerNodes')\n\n      const done = ((el as RenderElement).__active__ = () => {\n        onActiveFinish(el, props)\n      })\n\n      onBeforeActiveHook(el, props)\n      onActiveHook(el, props, done)\n    },\n    onLeave(el, remove) {\n      processFinish(state, vnode, 'activeInnerNodes', '__active__')\n      setInnerVNode(state, vnode, 'leaveInnerNodes')\n\n      const done = ((el as RenderElement).__remove__ = () => {\n        onLeaveFinish(el, props)\n        remove()\n      })\n\n      onBeforeLeaveHook(el, props)\n      onLeaveHook(el, props, done)\n    },\n    onLeaveFinish(el) {\n      onLeaveFinish(el, props)\n    },\n  }\n}\n\nfunction setTransition(vnode: VNode, hooks: TransitionHooks) {\n  vnode.transition = hooks\n}\n\nexport const Transition = FC<TransitionProps>(function Transition() {\n  const state = useTransitionState()\n  return function TransitionChildren(props, component) {\n    const n1 = component.subTree\n    const n2 = props.children\n\n    const normalizeProps = normalizeTransitionProps(props)\n    if (isVNode(n2) && !isVNodeComment(n2)) {\n      setTransition(n2, generateTransitionHook(n2, state, normalizeProps))\n    }\n\n    if (isVNode(n1) && !isVNodeComment(n1)) {\n      setTransition(n1, generateTransitionHook(n1, state, normalizeProps))\n    }\n\n    return n2\n  }\n})\n", "import type { Component } from './component'\nimport { extend, isString } from '@gyron/shared'\nimport { VNode } from './vnode'\nimport { ComponentSetupFunction, normalizeComponent } from './component'\n\nconst record: Map<string, Component> = /* #__PURE__ */ new Map()\nconst dep: Map<string, Set<string>> = /* #__PURE__ */ new Map()\n\nexport function refreshComponentType(\n  vnode: VNode<ComponentSetupFunction>,\n  component: Component\n) {\n  const hmrId = (vnode.type as any).__hmr_id\n  const hmrComponent = record.get(hmrId)\n  if (hmrComponent) {\n    vnode.type = hmrComponent.vnode.type\n    normalizeComponent(vnode, component)\n  }\n}\n\nexport function collectHmrComponent(\n  id: string,\n  parent: string,\n  component: Component\n) {\n  const instance = record.get(id)\n  if (!instance) {\n    record.set(id, component)\n  } else {\n    instance.type = component.type\n    instance.setup = component.setup\n  }\n  if (isString(parent)) {\n    const dependence = dep.get(id)\n    if (dependence) {\n      dependence.add(parent)\n    } else {\n      dep.set(id, new Set([parent]))\n    }\n  }\n}\n\nfunction rerenderParent(id: string) {\n  const dependence = dep.get(id)\n  if (dependence) {\n    for (const parent of dependence.values()) {\n      const instance = record.get(parent)\n      if (instance && instance.type) {\n        rerender(parent, instance.type as ComponentSetupFunction)\n      }\n    }\n  }\n}\n\n/**\n * Perform component hot update\n * @deprecated Only allowed for internal use, such as vite or other packaging tools\n */\nexport function rerender(id: string, type: ComponentSetupFunction) {\n  const instance = record.get(id)\n  if (instance) {\n    instance.setup = null\n    normalizeComponent(extend(instance.vnode, { type }), instance)\n\n    // update the information in the local snapshot\n    record.set(id, instance)\n\n    if (!instance.destroyed) {\n      instance.update()\n    }\n    rerenderParent(id)\n  } else {\n    if (__WARN__) {\n      console.warn(\n        'An exception occurs during the hot update collection task, please submit issues to us at https://github.com/gyronorg/core',\n        id,\n        type\n      )\n    }\n  }\n}\n", "import { Exposed } from './component'\nimport { RenderElement } from './vnode'\n\nexport type Ref = null | Exposed | RenderElement\nexport interface UserRef<T = Ref> {\n  current: T\n}\n\n/**\n * creates a `ref` object that can be bound to a `vnode` node. If the bound node is a normal node, its value is `Node`.\n * If it is a component, the value is the object exposed by the component.\n * A default value can be passed, `current` is the default value when the value is not bound.\n * ```javascript\n * import { h, createRef } from 'gyron'\n *\n * const App = h(() => {\n *   const myRef = createRef()\n *   return h('div', {\n *     ref: myRef,\n *   })\n * })\n * ```\n * @api global\n * @param initialValue initial value.\n */\nexport function createRef<T = any>(initialValue?: T): UserRef<T> {\n  return {\n    current: initialValue,\n  }\n}\n\nexport function setRef(ref: Ref, userRef: UserRef) {\n  userRef.current = ref\n}\n", "import type { VNode, RenderElement } from './vnode'\nimport type { SSRMessage } from './ssr'\nimport { shouldValue, isComment, extend, keys } from '@gyron/shared'\nimport {\n  createComment,\n  insert,\n  mountProps,\n  nextSibling,\n  remove,\n} from '@gyron/dom-client'\nimport {\n  Component,\n  ComponentSetupFunction,\n  removeBuiltInProps,\n} from './component'\nimport {\n  Text,\n  Comment,\n  Fragment,\n  Element,\n  NodeType,\n  normalizeChildrenVNode,\n  normalizeVNodeWithLink,\n} from './vnode'\nimport { mountComponent, patch } from './render'\nimport { setRef } from './ref'\n\n/**\n * Find the tag at the end of the Fragment and return the first node after the end\n * @param node \"[\" annotation node\n * @returns returns the first node after the \"]\" node\n */\nfunction locateClosingAsyncAnchor(node: Node): Node {\n  let match = 0\n  while (node) {\n    node = nextSibling(node)\n    if (node && isComment(node)) {\n      if (node.data === '[') match++\n      if (node.data === ']') {\n        if (match === 0) {\n          return nextSibling(node)\n        } else {\n          match--\n        }\n      }\n    }\n  }\n  return node\n}\n\nfunction mismatch(node: RenderElement, vnode: VNode, isFragment: boolean) {\n  if (__DEV__) {\n    console.warn(\n      `[hydrate] server render mismatch.\\nClient Type: `,\n      node,\n      `\\nServer Type: `,\n      vnode\n    )\n  }\n\n  vnode.el = null\n\n  if (isFragment) {\n    // remove excessive fragment nodes\n    const end = locateClosingAsyncAnchor(node)\n    while (true) {\n      const next = nextSibling(node)\n      if (next && next !== end) {\n        remove(next as Element)\n      } else {\n        break\n      }\n    }\n  }\n\n  const next = nextSibling(node)\n  const container = node.parentNode\n  remove(node as Element)\n\n  // Assert that client-side html and server-side vnode render do not match, re-render\n  patch(null, vnode, container, next)\n  return next\n}\n\n/**\n * Hydrate static resources to ensure ssr client responsiveness\n * @api global\n * @param node Node in a document\n * @param vnode Virtual node\n */\nexport function hydrate(\n  node: RenderElement,\n  vnode: VNode,\n  parentComponent: Component = null,\n  ssrMessage: SSRMessage = null\n) {\n  const isFragmentStart = isComment(node) && node.data === '['\n  const { type, children } = vnode\n\n  vnode.el = node\n\n  let nextNode: RenderElement = null\n  switch (type) {\n    case Text:\n      const textNode = node as Text\n      if (node.nodeType !== NodeType.Text) {\n        nextNode = mismatch(node, vnode, isFragmentStart)\n      } else {\n        if (textNode.data !== children) {\n          if (__DEV__) {\n            console.warn(\n              `[hydrate] text data mismatch.\\nserver text: ${textNode.data}\\nclient text: ${children}`\n            )\n          }\n          textNode.data = children as string\n        }\n        nextNode = nextSibling(node)\n      }\n      break\n    case Comment:\n      const commentNode = node as Comment\n      if (node.nodeType !== NodeType.Comment) {\n        nextNode = mismatch(node, vnode, isFragmentStart)\n      } else {\n        commentNode.data = (children || '') as string\n        nextNode = nextSibling(node)\n      }\n      break\n    case Fragment:\n      if (!isFragmentStart) {\n        nextNode = mismatch(node, vnode, isFragmentStart)\n      } else {\n        nextNode = hydrateFragment(node, vnode, parentComponent, ssrMessage)\n      }\n      break\n    case Element:\n      if (node.nodeType !== NodeType.Element) {\n        nextNode = mismatch(node, vnode, isFragmentStart)\n      } else {\n        nextNode = hydrateElement(node, vnode, parentComponent, ssrMessage)\n      }\n      break\n    default:\n      hydrateComponent(\n        vnode as VNode<ComponentSetupFunction>,\n        parentComponent,\n        ssrMessage\n      )\n      nextNode = isFragmentStart\n        ? locateClosingAsyncAnchor(node)\n        : nextSibling(node)\n  }\n\n  return nextNode\n}\n\nfunction hydrateComponent(\n  vnode: VNode<ComponentSetupFunction>,\n  parentComponent: Component = null,\n  ssrMessage: SSRMessage = null\n) {\n  const container = vnode.el.parentNode\n  if (ssrMessage && vnode.__uri) {\n    // use server-side data hydrate client\n    const ssrProps = ssrMessage[vnode.__uri]\n    extend(vnode.props, ssrProps)\n  }\n  mountComponent(vnode, container, vnode.anchor, parentComponent, ssrMessage)\n}\n\nfunction hydrateFragment(\n  node: RenderElement,\n  vnode: VNode,\n  parentComponent: Component = null,\n  ssrMessage: SSRMessage = null\n) {\n  const container = node.parentNode\n\n  // fragment not container\n  // clear el\n  vnode.el = null\n\n  const next = hydrateChildren(\n    nextSibling(node),\n    vnode,\n    container,\n    parentComponent,\n    ssrMessage\n  )\n  if (next && isComment(next) && next.data === ']') {\n    return nextSibling((vnode.anchor = next))\n  } else {\n    if (__DEV__) {\n      console.warn(\n        '[hydrate] RenderToString did not handle the fragment correctly, no terminator found'\n      )\n    }\n    insert((vnode.anchor = createComment(`]`)), container, next)\n    return next\n  }\n}\n\nfunction hydrateElement(\n  node: RenderElement,\n  vnode: VNode,\n  parentComponent: Component = null,\n  ssrMessage: SSRMessage = null\n) {\n  const { children, el } = vnode\n\n  if (vnode.props.ref) {\n    setRef(el, vnode.props.ref)\n  }\n\n  const props = removeBuiltInProps(vnode.props)\n  if (shouldValue(keys(props))) {\n    mountProps(el as HTMLElement, extend({}, vnode, { props: props }))\n  }\n\n  if (shouldValue(children)) {\n    vnode.children = normalizeChildrenVNode(vnode)\n    hydrateChildren(node.firstChild, vnode, node, parentComponent, ssrMessage)\n  }\n\n  return nextSibling(node)\n}\n\nfunction hydrateChildren(\n  node: RenderElement,\n  parentVNode: VNode,\n  container: RenderElement,\n  parentComponent: Component = null,\n  ssrMessage: SSRMessage = null\n) {\n  const children = parentVNode.children as VNode[]\n  for (let i = 0; i < children.length; i++) {\n    const nodeChild = normalizeVNodeWithLink(children[i], parentVNode)\n    if (node) {\n      node = hydrate(node, nodeChild, parentComponent, ssrMessage)\n    } else if (nodeChild.type === Text) {\n      continue\n    } else {\n      patch(null, nodeChild, container)\n    }\n  }\n  return node\n}\n", "import type { Noop } from '@gyron/shared'\nimport type { Component } from './component'\nimport { ErrorHandlingType, callWithErrorHandling } from './component'\n\nexport interface SchedulerJob {\n  (): void\n  id: number\n  component: Component\n  priority: JobPriority\n}\n\nconst queue: SchedulerJob[] = []\nconst resolvedPromise: Promise<unknown> = Promise.resolve()\nconst frameYield = 5\nconst delaysTime = 1000 / 60\nconst pendingJobPromise: Promise<unknown>[] = []\nlet currentJobPromise: Promise<unknown>\nlet startTime = -1\n\n/**\n * Update tasks need to be prioritized, with those of higher priority being executed first, followed by those of lower priority.\n */\nexport enum JobPriority {\n  DEFERRED = -1,\n  NORMAL = 0,\n  ACCRUED = 1,\n}\n\n/**\n * Wait for the data to finish rendering and the updated DOM node will be available in the next tick.\n * ```js\n * import { h, useValue, nextRender, createRef, onAfterMount } from 'gyron'\n *\n * const App = h(() => {\n *   const count = useValue(0)\n *   const ref = createRef()\n *\n *   onAfterMount(() => {\n *     count.value++\n *     nextRender().then(() => {\n *       console.log(ref.current.innerText) // 1\n *     })\n *     console.log(ref.current.innerText) // 0\n *   })\n *   return h('div', { ref }, count.value)\n * })\n *```\n * @param fn The next scale call function.\n * @returns Returns a Promise that changes the state of a task only after all tasks have completed, regardless of how long the task has been executed.\n */\nexport function nextRender(fn?: Noop) {\n  const p = Promise.all(pendingJobPromise || [resolvedPromise]).finally(() => {\n    pendingJobPromise.length = 0\n  })\n  return fn ? p.then(fn) : p\n}\n\nexport function useDeferred(fn: Noop) {\n  //\n}\n\nexport function useAccrued(fn: Noop) {\n  //\n}\n\nexport function pushQueueJob(job: SchedulerJob) {\n  if (job.id === null) {\n    queue.push(job)\n  } else {\n    // same component update using the latest data update\n    // array.prototype.splice will trigger update multiple times, the first time the data is incorrect, see Proxy splice set\n    const index = queue.findIndex((item) => item.id === job.id)\n    if (index >= 0) {\n      // priorities the same component update to completion.\n      // when multiple updates of the same component are found in a synchronous task,\n      // insert its next task at the end of an update task of the same type.\n      // jobId = 3; queue = [1, 3, 5]\n      // queue = [1, 3, 5]\n      queue.splice(index, 1, job)\n    } else {\n      queue.push(job)\n    }\n  }\n\n  currentJobPromise = resolvedPromise.then(flushJobs)\n  pendingJobPromise.push(currentJobPromise)\n}\n\nexport function flushJobs() {\n  try {\n    startTime = now()\n    // opt the behavior of multiple components when synchronized updates block the host process,\n    // returning execution to the host when the threshold is exceeded and continuing the\n    // component update task when the host environment is free\n    return workLoop()\n  } catch {\n    queue.length = 0\n  }\n}\n\nexport const now = () => {\n  return typeof performance === 'object' ? performance.now() : Date.now()\n}\n\nconst self = typeof global === 'object' ? global : window\n\nconst navigator = self.navigator as Navigator & {\n  scheduling: { isInputPending: () => boolean }\n}\n\n// https://web.dev/isinputpending/\nconst isInputPending: () => boolean =\n  typeof navigator !== 'undefined' &&\n  navigator.scheduling !== undefined &&\n  navigator.scheduling.isInputPending !== undefined\n    ? navigator.scheduling.isInputPending.bind(navigator.scheduling)\n    : null\n\nconst timeout = (callback: Noop, ms: number) => {\n  if (self.requestIdleCallback) {\n    requestIdleCallback(callback, { timeout: ms })\n  } else {\n    setTimeout(callback, ms)\n  }\n}\n\nexport function cancelTimeout(callback: number) {\n  if (self.requestIdleCallback) {\n    cancelIdleCallback(callback)\n  } else {\n    clearTimeout(callback)\n  }\n}\n\nfunction shouldYieldHost() {\n  if (now() - startTime > frameYield) {\n    return true\n  }\n  if (isInputPending !== null) {\n    return isInputPending()\n  }\n  return true\n}\n\nfunction workLoop(pendingJobs?: SchedulerJob[]) {\n  return new Promise<void>((resolve) => {\n    // guaranteed top-down update order\n    queue.sort((a, b) => a.id - b.id)\n    const jobs = pendingJobs || queue\n\n    let currentJob = jobs.shift()\n    let idleJob: Promise<void>\n    while (currentJob) {\n      callWithErrorHandling(\n        currentJob,\n        currentJob.component,\n        ErrorHandlingType.Scheduler\n      )\n      if (shouldYieldHost() && jobs.length > 0) {\n        // if there are still unUpdated tasks, put the unUpdated tasks to continue when the browser is free\n        idleJob = new Promise<void>((resolve) => {\n          startTime = now()\n          // identify suitable opportunities to perform outstanding updates again\n          const pendingJobs = [...jobs]\n          timeout(() => {\n            workLoop(pendingJobs).then(resolve)\n          }, delaysTime)\n          jobs.length = 0\n        })\n        break\n      }\n      currentJob = jobs.shift()\n    }\n    if (idleJob) {\n      idleJob.then(resolve)\n    } else {\n      resolve()\n    }\n  })\n}\n", "import {\n  createComment,\n  createElement,\n  createText,\n  insert,\n  isSelectElement,\n  mountProps,\n  nextSibling,\n  patchProps,\n  remove,\n} from '@gyron/dom-client'\nimport {\n  asyncTrackEffect,\n  clearTrackEffect,\n  createEffect,\n} from '@gyron/reactivity'\nimport {\n  extend,\n  isArray,\n  isBoolean,\n  isElement,\n  isEqual,\n  isFunction,\n  isObject,\n  isPromise,\n  keys,\n  Noop,\n  shouldValue,\n} from '@gyron/shared'\nimport { warn } from './assert'\nimport {\n  Component,\n  ComponentSetupFunction,\n  createComponentInstance,\n  getCacheComponent,\n  isAsyncComponent,\n  isCacheComponent,\n  renderComponent,\n  normalizeComponent,\n  removeBuiltInProps,\n} from './component'\nimport { collectHmrComponent, refreshComponentType } from './hmr'\nimport { hydrate } from './hydrate'\nimport { invokeLifecycle } from './lifecycle'\nimport { setRef } from './ref'\nimport { JobPriority, pushQueueJob, SchedulerJob } from './scheduler'\nimport { isVNode, isVNodeComponent } from './shared'\nimport { SSRMessage } from './ssr'\nimport {\n  Children,\n  Comment,\n  Element,\n  Fragment,\n  mergeVNodeWith,\n  normalizeChildrenVNode,\n  normalizeVNode,\n  RenderElement,\n  Text,\n  VNode,\n} from './vnode'\n\nfunction shouldUpdate(result: any) {\n  return !(isBoolean(result) && !result)\n}\n\nexport function isSameVNodeType(n1: VNode, n2: VNode) {\n  return n1.type === n2.type && n1.key === n2.key\n}\n\nfunction isKeyPatch(n1: VNode[], n2: VNode[]) {\n  if (n1 && n2 && n1[0] && n2[0] && isObject(n1[0]) && isObject(n2[0])) {\n    return shouldValue(n1[0].key) && shouldValue(n2[0].key)\n  }\n  return false\n}\n\nfunction getNextSibling(vnode: VNode) {\n  if (vnode.component) {\n    return getNextSibling(vnode.component.subTree)\n  }\n  if (vnode.el || vnode.anchor) {\n    return nextSibling(vnode.el || vnode.anchor)\n  }\n  return null\n}\n\nfunction mountChildren(\n  nodes: VNode[] | Children[],\n  container: RenderElement,\n  anchor: RenderElement,\n  start = 0,\n  parentComponent: Component | null = null,\n  isSvg: boolean\n) {\n  for (let i = start; i < nodes.length; i++) {\n    const node = normalizeVNode(nodes[i])\n    patch(null, node, container, anchor, parentComponent, isSvg)\n  }\n}\n\nfunction removeInvoke(_el: RenderElement, vnode: VNode, done: Noop) {\n  const { transition } = vnode\n  const el = _el as Element\n  if (transition) {\n    transition.onLeave(el, () => {\n      remove(el)\n      done()\n    })\n  } else {\n    remove(el)\n    done()\n  }\n}\n\nexport function unmount(vnode: VNode) {\n  if (!isVNode(vnode)) {\n    return null\n  }\n\n  function reset() {\n    vnode.el = null\n  }\n  const { el, component, children, transition } = vnode\n\n  if (component) {\n    if (!isCacheComponent(component.type)) {\n      component.effect.stop()\n    }\n    if (component.subTree) {\n      unmount(component.subTree)\n    }\n    invokeLifecycle(component, 'destroyed')\n    if (component.$el) {\n      removeInvoke(component.$el, vnode, reset)\n      if (!isCacheComponent(component.type)) {\n        component.$el = null\n      }\n    }\n    component.destroyed = true\n    component.mounted = false\n  } else {\n    if (!transition) {\n      if (isArray(children) && children.length > 0) {\n        unmountChildren(children as VNode[])\n      } else {\n        unmount(children as VNode)\n      }\n    }\n    if (isElement(el)) {\n      removeInvoke(el, vnode, reset)\n    }\n  }\n}\n\nfunction unmountChildren(c1: VNode[], start = 0) {\n  for (let i = start; i < c1.length; i++) {\n    unmount(c1[i])\n  }\n}\n\nfunction patchNonKeyed(\n  c1: VNode[],\n  c2: VNode[],\n  container: RenderElement,\n  anchor: RenderElement,\n  parentComponent: Component,\n  isSvg: boolean\n) {\n  const c1length = c1.length\n  const c2length = c2.length\n  const minLength = Math.min(c1length, c2length)\n  for (let i = 0; i < minLength; i++) {\n    const prevChild = c1[i]\n    const nextChild = c2[i]\n    patch(prevChild, nextChild, container, anchor, parentComponent)\n  }\n  if (c1length > c2length) {\n    unmountChildren(c1, minLength)\n  } else {\n    mountChildren(c2, container, anchor, minLength, parentComponent, isSvg)\n  }\n}\n\nfunction patchKeyed(\n  c1: VNode[],\n  c2: VNode[],\n  container: RenderElement,\n  anchor: RenderElement | null,\n  parentComponent: Component | null,\n  isSvg: boolean\n) {\n  const o1: Record<\n    string | symbol,\n    VNode & { index: number; inserted: boolean }\n  > = c1.reduce((nodeMap, node, index) => {\n    nodeMap[node.key] = extend(node, { index })\n    return nodeMap\n  }, {})\n\n  const e2 = c2.length\n  let i = 0\n  while (i < e2) {\n    const c2n = c2[i]\n    const c1n = o1[c2n.key]\n    if (c1n) {\n      // 1, find the same key value of the node, and then inserted into the corresponding location. (Do not delete add, move directly)\n      const el = mergeVNodeWith(c2n, c1n).el\n      if (c1n.index !== i) {\n        // insert to new position when node order is changed\n        const anchor = container.childNodes[i]\n        if (el !== anchor.nextSibling) {\n          insert(el, container, anchor.nextSibling)\n        }\n      }\n      // update props after migration is complete\n      // element update attribute\n      if (!isEqual(c1n.props, c2n.props)) {\n        const isComponent = isVNodeComponent(c2n) && isVNodeComponent(c1n)\n        if (isComponent) {\n          patchComponent(c1n, c2n, container, anchor, parentComponent)\n        } else {\n          patchProps(\n            el as HTMLElement,\n            c1n,\n            extend({}, c2n, { props: removeBuiltInProps(c2n.props) })\n          )\n        }\n      }\n      // 1, end\n\n      if (c1n.children || c2n.children) {\n        // 2, update the nodes with the same key value, including the child nodes.\n        // sub-level nodes need to be patched again\n        patchChildren(c1n, c2n, container, anchor, parentComponent, isSvg)\n        // 2, end\n      }\n\n      // mark nodes that have been moved and do not need to be uninstalled in the third step\n      c1n.inserted = true\n    } else {\n      patch(null, c2n, container, anchor, parentComponent, isSvg)\n    }\n    i++\n  }\n\n  for (const node of Object.values(o1)) {\n    if (!node.inserted) {\n      // 3, uninstall the old nodes that are not used.\n      unmount(node)\n      // 3, end\n    }\n  }\n}\n\nfunction patchChildren(\n  n1: VNode,\n  n2: VNode,\n  container: RenderElement,\n  anchor: RenderElement,\n  parentComponent: Component,\n  isSvg: boolean\n) {\n  if (isFunction(n1.children) && isFunction(n2.children)) {\n    // when the child nodes are all functions, they should be called by the parent node.\n    // <Parent>{count => <Title count={count} />}</Parent>\n    return\n  }\n\n  const c1memo = n1.props.memo\n  const c2memo = n2.props.memo\n  if (isArray(c1memo) && isArray(c2memo)) {\n    const index = c1memo.findIndex((item, index) => {\n      return c2memo[index] !== item\n    })\n    if (index < 0) {\n      n2.children = n1.children\n      return\n    }\n  }\n\n  const c1 = n1.children as VNode[]\n  const c2: VNode[] = (n2.children = normalizeChildrenVNode(n2))\n\n  if (c1?.length || c2?.length) {\n    if (isKeyPatch(c1, c2)) {\n      const el = (n2.el = n1.el)\n      patchKeyed(c1, c2, el || container, anchor, parentComponent, isSvg)\n    } else {\n      // if the fragment node does not have a dom instance, use the container\n      const el = (n2.el = n1.el)\n      if (c1) {\n        patchNonKeyed(c1, c2, el || container, anchor, parentComponent, isSvg)\n      } else {\n        mountChildren(c2, el || container, anchor, 0, parentComponent, isSvg)\n      }\n    }\n  }\n}\n\nfunction mountElement(\n  vnode: VNode,\n  container: RenderElement,\n  anchor: RenderElement,\n  parentComponent: Component,\n  isSvg: boolean\n) {\n  const { tag, is, transition } = vnode\n  const el = (vnode.el = createElement(tag, isSvg, is) as RenderElement)\n  el.__vnode__ = vnode\n\n  if (vnode.props.ref) {\n    setRef(el, vnode.props.ref)\n  }\n\n  const props = removeBuiltInProps(vnode.props)\n  if (shouldValue(keys(props))) {\n    mountProps(el as HTMLElement, extend({}, vnode, { props: props }))\n  }\n\n  if (shouldValue(vnode.children)) {\n    vnode.children = normalizeChildrenVNode(vnode)\n    mountChildren(vnode.children, vnode.el, anchor, 0, parentComponent, isSvg)\n  }\n\n  insert(el, container, anchor)\n\n  if (transition) {\n    transition.onActive(el as Element)\n  }\n}\n\nfunction patchElement(\n  n1: VNode,\n  n2: VNode,\n  container: RenderElement,\n  anchor: RenderElement,\n  parentComponent: Component,\n  isSvg: boolean\n) {\n  const el = (n2.el = n1.el) as Element\n  if (el.nodeName === n2.tag.toLocaleUpperCase()) {\n    if (!isEqual(n1.props, n2.props) || isSelectElement(n2)) {\n      patchProps(\n        el,\n        n1,\n        extend({}, n2, { props: removeBuiltInProps(n2.props) })\n      )\n    }\n    if (n1.children || n2.children) {\n      patchChildren(n1, n2, container, anchor, parentComponent, isSvg)\n    }\n  } else {\n    anchor = getNextSibling(n1)\n    unmount(n1)\n    patch(null, n2, container, anchor, parentComponent, isSvg)\n  }\n}\n\nfunction patchSubTree(component: Component, prevTree: VNode, nextTree: VNode) {\n  component.subTree = nextTree\n  if (component.mounted) {\n    const { anchor } = prevTree\n    component.subTree.anchor = anchor\n    patch(prevTree, nextTree, component.$parent, anchor, component)\n    // onAfterUpdate\n    invokeLifecycle(component, 'afterUpdates')\n    component.$el = nextTree.el\n  } else {\n    // mount\n    patch(null, nextTree, component.$parent, component.vnode.anchor, component)\n    // after the render is complete, set el to the vnode for comparison\n    // dummy ? <componentA /> : <componentB />\n    component.vnode.el = nextTree.el\n    component.$el = nextTree.el\n    component.mounted = true\n    // onAfterMount\n    component.effect.allowEffect = true\n    invokeLifecycle(component, 'afterMounts')\n    component.effect.allowEffect = false\n  }\n}\n\nfunction updateComponentEffect(\n  component: Component,\n  ssrMessage: SSRMessage = null\n) {\n  if (component.mounted) {\n    // if the onBeforeUpdate callback function returns falsy\n    // no update of the component is performed\n    if (\n      shouldUpdate(invokeLifecycle(component, 'beforeUpdates')) &&\n      shouldUpdate(!component.props.static)\n    ) {\n      if (__DEV__) {\n        refreshComponentType(component.vnode, component)\n      }\n\n      const prevTree = component.subTree\n      const nextTree = renderComponent(component)\n      if (isPromise(nextTree)) {\n        warn(\n          'Asynchronous components without wrapping are not supported, please use FCA wrapping',\n          component,\n          'UpdateComponent'\n        )\n      } else {\n        patchSubTree(component, prevTree, nextTree)\n      }\n    }\n  } else if (!component.destroyed) {\n    if (component.vnode.el) {\n      function hydrateSubTree() {\n        const nextTree = renderComponent(component)\n        component.subTree = nextTree as VNode\n        hydrate(component.vnode.el, component.subTree, component, ssrMessage)\n\n        component.mounted = true\n        // onAfterMount\n        invokeLifecycle(component, 'afterMounts')\n      }\n      // asynchronous component rendering in ssr mode\n      if (isAsyncComponent(component.vnode.type)) {\n        component.vnode.type.__loader(component.props, component).then(() => {\n          if (!component.destroyed) {\n            asyncTrackEffect(component.effect)\n            hydrateSubTree()\n            clearTrackEffect()\n          }\n        })\n      } else {\n        hydrateSubTree()\n      }\n    } else {\n      const nextTree = renderComponent(component)\n      if (isPromise(nextTree)) {\n        warn(\n          'Asynchronous components without wrapping are not supported, please use FCA wrapping',\n          component,\n          'SetupPatch'\n        )\n      } else {\n        nextTree.transition ||= component.vnode.transition\n        patchSubTree(component, null, nextTree)\n      }\n    }\n  }\n}\n\nfunction renderComponentEffect(\n  component: Component,\n  ssrMessage: SSRMessage = null\n) {\n  const effect = (component.effect = createEffect(\n    updateComponentEffect.bind(null, component, ssrMessage),\n    () => pushQueueJob(component.update)\n  ))\n\n  const update = (component.update = effect.run.bind(effect) as SchedulerJob)\n  update.id = component.uid\n  update.component = component\n  update.priority = JobPriority.NORMAL\n  update()\n}\n\nexport function mountComponent(\n  vnode: VNode<ComponentSetupFunction>,\n  container: RenderElement,\n  anchor: RenderElement,\n  parentComponent: Component,\n  ssrMessage: SSRMessage = null\n) {\n  vnode.anchor = anchor\n\n  const component = (vnode.component = createComponentInstance(\n    vnode,\n    parentComponent\n  ))\n  component.$parent = container\n\n  // if (vnode.transition) {\n  //   const { innerCache, transitionLeaving } = vnode.transition.state\n  //   const innerVNode = innerCache.get(vnode.type)\n  //   if (innerVNode && transitionLeaving) {\n  //     const subTree = getVNodeWithComponent(innerVNode)\n  //     // when a component is wrapped by a Transition, mark the component as active\n  //     component.mounted = true\n  //     component.subTree = subTree\n  //   }\n  // }\n\n  if (__DEV__ && (component.type as any).__hmr_id) {\n    refreshComponentType(vnode, component)\n\n    const parentId: string = parentComponent\n      ? (parentComponent.type as any).__hmr_id\n      : null\n    collectHmrComponent((component.type as any).__hmr_id, parentId, component)\n  }\n\n  if (component.props.ref) {\n    setRef(component.exposed, component.props.ref)\n  }\n\n  renderComponentEffect(component, ssrMessage)\n}\n\nfunction patchComponent(\n  n1: VNode<ComponentSetupFunction>,\n  n2: VNode<ComponentSetupFunction>,\n  container: RenderElement,\n  anchor: RenderElement,\n  parentComponent: Component\n) {\n  const component = (n2.component = n1.component)\n  if (component) {\n    normalizeComponent(n2, component, parentComponent)\n    if (isCacheComponent(n1.component.type)) {\n      if (!isEqual(n1.props, n2.props)) {\n        component.update()\n      }\n    } else {\n      component.update()\n    }\n  } else {\n    if (__WARN__) {\n      console.warn('Component update exception', n1)\n    }\n    mountComponent(n2, container, anchor, parentComponent)\n  }\n}\n\nfunction enterComponent(\n  n1: VNode<ComponentSetupFunction> | null,\n  n2: VNode<ComponentSetupFunction>,\n  container: RenderElement,\n  anchor: RenderElement,\n  parentComponent: Component\n) {\n  if (n1 === null) {\n    // clear the element of the next vnode to prevent access to the SSR hydrate logic.\n    n2.el = null\n    if (isCacheComponent(n2.type)) {\n      // update the DOM with the locally cached component state when a local component cache is found\n      const component = getCacheComponent(n2.type)\n      component.destroyed = false\n      component.mounted = true\n      component.vnode = n2\n      component.$parent = container\n      if (isEqual(removeBuiltInProps(component.props), n2.props)) {\n        patch(null, component.subTree, container, anchor, parentComponent)\n      } else {\n        mountComponent(n2, container, anchor, parentComponent)\n      }\n    } else {\n      mountComponent(n2, container, anchor, parentComponent)\n    }\n  } else {\n    n2.anchor ||= n1.anchor\n    patchComponent(n1, n2, container, anchor, parentComponent)\n  }\n}\n\nfunction transitionMove(\n  n1: VNode,\n  n2: VNode,\n  container: RenderElement,\n  anchor: RenderElement,\n  parentComponent: Component,\n  isSvg: boolean\n) {\n  const { transition } = n1\n  const el = n1.el as Element\n  transition.onLeaveFinish(el)\n  unmount(n1)\n  patch(\n    null,\n    n2,\n    container,\n    anchor || getNextSibling(n1),\n    parentComponent,\n    isSvg\n  )\n}\n\nfunction enterElement(\n  n1: VNode | null,\n  n2: VNode,\n  container: RenderElement,\n  anchor: RenderElement,\n  parentComponent: Component,\n  isSvg: boolean\n) {\n  isSvg = isSvg || n2.tag === 'svg'\n\n  if (n1 === null) {\n    mountElement(n2, container, anchor, parentComponent, isSvg)\n  } else if (!n2.props.static) {\n    if (n1.transition) {\n      transitionMove(n1, n2, container, anchor, parentComponent, isSvg)\n    } else {\n      patchElement(n1, n2, container, anchor, parentComponent, isSvg)\n    }\n  }\n}\n\nfunction enterFragment(\n  n1: VNode | null,\n  n2: VNode,\n  container: RenderElement,\n  anchor: RenderElement,\n  parentComponent: Component,\n  isSvg: boolean\n) {\n  const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : createText(''))\n  if (n1 === null) {\n    n2.anchor = fragmentEndAnchor\n    insert(fragmentEndAnchor, container, anchor)\n\n    n2.children = normalizeChildrenVNode(n2)\n    mountChildren(\n      n2.children,\n      container,\n      fragmentEndAnchor,\n      0,\n      parentComponent,\n      isSvg\n    )\n  } else {\n    patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, isSvg)\n  }\n}\n\nfunction enterComment(\n  n1: VNode | null,\n  n2: VNode,\n  container: RenderElement,\n  anchor: RenderElement\n) {\n  if (n1 === null) {\n    const comment = createComment(\n      (n2.children as string) || ''\n    ) as RenderElement\n    comment.__vnode__ = n2\n\n    n2.el = comment as RenderElement\n    insert(comment, container, anchor)\n  } else {\n    n2.el = n1.el\n    n2.el.__vnode__ = n2\n  }\n}\n\nfunction enterText(\n  n1: VNode | null,\n  n2: VNode,\n  container: RenderElement,\n  anchor: RenderElement\n) {\n  if (n1 === null || !n1.el) {\n    // when hydrating the code, since there is no empty text node on the server side, you need to execute mountText\n    const textNode = createText(n2.children as string) as RenderElement\n\n    textNode.__vnode__ = n2\n    n2.el = textNode\n\n    insert(textNode, container, anchor)\n  } else {\n    const el = (n2.el = n1.el)\n\n    const c1 = '' + n1.children\n    const c2 = '' + n2.children\n\n    if (c1 !== c2) {\n      el.textContent = c2\n    }\n  }\n}\n\nexport function patch(\n  n1: VNode | null,\n  n2: VNode,\n  container: RenderElement,\n  anchor: RenderElement | null = null,\n  parentComponent: Component | null = null,\n  isSvg = false\n) {\n  if (!container) {\n    throw new Error(\n      'The parent element is not found when updating, please check the code.'\n    )\n  }\n\n  if (n1 && !isSameVNodeType(n1, n2)) {\n    anchor = getNextSibling(n1)\n    unmount(n1)\n    n1 = null\n  }\n\n  switch (n2.type) {\n    case Text:\n      enterText(n1, n2, container, anchor)\n      break\n    case Comment:\n      enterComment(n1, n2, container, anchor)\n      break\n    case Element:\n      enterElement(n1, n2, container, anchor, parentComponent, isSvg)\n      break\n    case Fragment:\n      enterFragment(n1, n2, container, anchor, parentComponent, isSvg)\n      break\n    default:\n      enterComponent(\n        n1 as VNode<ComponentSetupFunction>,\n        n2 as VNode<ComponentSetupFunction>,\n        container,\n        anchor,\n        parentComponent\n      )\n  }\n}\n", "import type { RenderElement, VNode } from './vnode'\nimport { patch, unmount } from './render'\nimport { hydrate } from './hydrate'\nimport { checkVersion } from './version'\nimport { getUserContainer } from './shared'\n\nexport interface Instance {\n  container: Element | null\n  render: (containerOrSelector: string | Element) => Instance\n  destroy: () => Instance\n}\n\nexport function createContext() {\n  return new Map()\n}\n\n/**\n * Render virtual nodes to the real DOM.\n * ```js\n * import { render, h } from 'gyron'\n *\n * render(h('div', { id: 'gyron' }), document.body)\n * ```\n * @api global\n * @param vnode Virtual node\n * @param container Browser nodes\n */\nexport function render(vnode: VNode, container: Element) {\n  patch(null, vnode, container)\n}\n\n/**\n * Create the application and render it as an actual DOM node via the `render` method on the application.\n * ```js\n * import { h, createInstance } from 'gyron'\n *\n * const App = h(() => {\n *   return h('div', 'hello world')\n * })\n *\n * createInstance(h(App)).render('#root')\n * ```\n * @api global\n * @param root A `VNode` node, which can be created with the `h` function.\n * @param isHydrate For server-side rendering parameters, `Truthy` means that the \"hydration\" method is used to make the interface responsive.\n * @returns Application examples.\n */\nexport function createInstance(root: VNode, isHydrate?: boolean) {\n  if (__DEV__) {\n    checkVersion()\n  }\n\n  const instance: Instance = {\n    container: null,\n    render(containerOrSelector) {\n      instance.container = getUserContainer(containerOrSelector)\n\n      if (!instance.container) {\n        console.warn(\n          'Node not found in the document. The parameter is',\n          containerOrSelector\n        )\n        return null\n      }\n\n      const firstChild = instance.container.firstChild\n      // hydration application in ssr mode\n      // or spa mode when reusing elements\n      if (\n        isHydrate ||\n        (firstChild && (firstChild as RenderElement).__vnode__)\n      ) {\n        hydrate(firstChild, root)\n        return instance\n      }\n\n      render(root, instance.container)\n      return instance\n    },\n    destroy() {\n      if (instance.container) {\n        unmount(root)\n      }\n      return instance\n    },\n  }\n\n  return instance\n}\n", "import { createContext } from './instance'\n\nexport const plugins = createContext()\n\nexport interface Plugin<D extends object, E = any> {\n  data: D\n  extra?: E\n  name?: string\n}\n\n/**\n * Return all registered plugins\n * ```js\n * import { getPlugins } from 'gyron'\n * const plugins = getPlugins()\n * ```\n * @api global\n * @returns Map\n */\nexport function getPlugins() {\n  return plugins\n}\n", "import { extend } from '@gyron/shared'\nimport { hydrate } from './hydrate'\nimport { createInstance, Instance } from './instance'\nimport { getUserContainer } from './shared'\nimport { VNode } from './vnode'\n\nexport interface SSRInstance extends Instance {\n  root: VNode\n}\n\n/**\n * Create a server-side application. The parameter `isSSR` is always true for all components in the server-side application.\n * ```javascript\n * import { h, createSSRInstance, renderToString } from 'gyron'\n *\n * const App = h(() => {\n *   return h('div', 'hello world')\n * })\n *\n * const { root } = createSSRInstance(h(App))\n *\n * renderToString(root).then((html) => {\n *   console.log(html)\n *   // <div>hello world</div>\n * })\n * ```\n * @api global\n * @param vnode Virtual node\n * @returns return SSRInstance object\n * @deprecated createSSRInstance is deprecated and may be removed in a future version, please use createSSRContext instead\n */\nexport function createSSRInstance(vnode: VNode): SSRInstance {\n  const ssr = createInstance(vnode, true)\n  return extend(ssr, { root: vnode })\n}\n\nexport interface SSRMessage {\n  [key: string]: Record<string, any>\n}\n\nexport interface SSRContext {\n  message: SSRMessage\n}\n\n/**\n * When creating the server rendering context, you can obtain the props based on the component URI at the initial rendering to enable the client to hydrate.\n * @api global\n * @param context The initial state of the context\n * @returns Returns an object, including the render function for \"hydrate\"\n */\nexport function createSSRContext(context: SSRContext) {\n  return {\n    render: (vnode: VNode, containerOrSelector: string | HTMLElement) => {\n      const container = getUserContainer(containerOrSelector)\n      if (!container) {\n        console.warn(\n          'Node not found in the document. The parameter is',\n          containerOrSelector\n        )\n        return null\n      }\n\n      hydrate(container.firstChild, vnode, null, context.message)\n      return vnode\n    },\n  }\n}\n", "/**\n * The Babel Team (https://babel.dev/team)\n * Link (linkorgs@163.com)\n * import by \"@babel/helpers\" v7.18.6\n * The functions exported here are used to do tree shaking when building helper code\n */\n\nexport function objectWithoutPropertiesLoose(\n  source: object,\n  excluded: string[]\n) {\n  if (source == null) return {}\n\n  const target = {}\n  const sourceKeys = Object.keys(source)\n  let key: string, i: number\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i]\n    if (excluded.indexOf(key) >= 0) continue\n    target[key] = source[key]\n  }\n\n  return target\n}\n\nexport function toPrimitive(input: any, hint: string) {\n  if (typeof input !== 'object' || input === null) return input\n  const prim = input[Symbol.toPrimitive]\n  if (prim !== undefined) {\n    const res = prim.call(input, hint || 'default')\n    if (typeof res !== 'object') return res\n    throw new TypeError('@@toPrimitive must return a primitive value.')\n  }\n  return (hint === 'string' ? String : Number)(input)\n}\n\nexport function toPropertyKey(arg: any) {\n  const key = toPrimitive(arg, 'string')\n  return typeof key === 'symbol' ? key : String(key)\n}\n\nexport function objectDestructuringEmpty(obj: any) {\n  if (obj == null) throw new TypeError('Cannot destructure undefined')\n}\n", "export * from './jsx.d'\n\nexport * from '@gyron/runtime'\n\nexport * from './helper'\n\nimport * as gyron from '@gyron/runtime'\n\nexport default gyron\n"],
  "mappings": "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",
  "names": ["fn", "dep", "key", "has", "get", "key", "get", "set", "has", "error", "warn", "subTree", "render", "ErrorHandlingType", "ErrorBoundary", "warn", "remove", "Transition", "next", "resolve", "pendingJobs", "anchor", "index"]
}
